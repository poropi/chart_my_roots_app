# PDF出力機能 詳細設計書

## 1. 概要

PDF出力機能は、ユーザーが作成した家系図をPDFファイルとして出力する機能です。A4などの標準用紙サイズで印刷可能な形式で保存し、家系図を共有したり、実際に印刷して保管することができます。Flutter/Dartでの実装を前提とした詳細設計を記載します。

## 2. クラス設計

### 2.1 PDF生成関連のモデルクラス

#### PdfSettings クラス

PDF出力の設定情報を保持するクラスです。

```dart
// lib/features/pdf_export/models/pdf_settings.dart
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:pdf/pdf.dart';

part 'pdf_settings.freezed.dart';
part 'pdf_settings.g.dart';

@freezed
class PdfSettings with _$PdfSettings {
  const factory PdfSettings({
    required String title,
    @Default(PdfPageFormat.a4) PdfPageFormat pageFormat,
    @Default(PdfOrientation.portrait) PdfOrientation orientation,
    @Default(true) bool showDate,
    @Default(true) bool showLegend,
    @Default(false) bool fitToSinglePage,
  }) = _PdfSettings;

  factory PdfSettings.fromJson(Map<String, dynamic> json) =>
      _$PdfSettingsFromJson(json);
}

enum PdfOrientation {
  portrait,
  landscape,
}

// PdfPageFormatのシリアライザ拡張
extension PdfPageFormatJson on PdfPageFormat {
  static PdfPageFormat fromString(String format) {
    switch (format) {
      case 'a4':
        return PdfPageFormat.a4;
      case 'a3':
        return PdfPageFormat.a3;
      case 'letter':
        return PdfPageFormat.letter;
      default:
        return PdfPageFormat.a4;
    }
  }
  
  String toFormatString() {
    if (this == PdfPageFormat.a4) {
      return 'a4';
    } else if (this == PdfPageFormat.a3) {
      return 'a3';
    } else if (this == PdfPageFormat.letter) {
      return 'letter';
    } else {
      return 'custom';
    }
  }
}
```

### 2.2 PDFジェネレータークラス

#### FamilyTreePdfGenerator クラス

家系図からPDFを生成するコアクラスです。

```dart
// lib/features/pdf_export/services/family_tree_pdf_generator.dart
import 'dart:typed_data';
import 'package:chart_my_roots_app/features/family_tree/layout/tree_layout_engine.dart';
import 'package:chart_my_roots_app/features/pdf_export/models/pdf_settings.dart';
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;

class FamilyTreePdfGenerator {
  // 日本語フォントデータ
  final Uint8List? _japaneseFontData;

  FamilyTreePdfGenerator({Uint8List? japaneseFontData})
      : _japaneseFontData = japaneseFontData;

  // PDF生成メイン関数
  Future<Uint8List> generatePdf({
    required FamilyTreeData familyTreeData,
    required PdfSettings settings,
  }) async {
    // PDFドキュメントを作成
    final pdf = pw.Document();

    // 日本語フォントを設定
    final font = _japaneseFontData != null
        ? pw.Font.ttf(_japaneseFontData!)
        : null;

    // ページフォーマットの設定
    final pageFormat = settings.orientation == PdfOrientation.portrait
        ? settings.pageFormat
        : settings.pageFormat.landscape;

    // 家系図のレイアウト計算
    final orientation = settings.orientation == PdfOrientation.portrait
        ? LayoutOrientation.vertical
        : LayoutOrientation.horizontal;

    final treeLayout = TreeLayoutEngine.calculateLayout(
      persons: familyTreeData.persons,
      relationships: familyTreeData.relationships,
      orientation: orientation,
    );

    // レイアウトをPDFに合わせて調整
    final adjustedLayout = _adjustLayoutForPdf(
      treeLayout,
      pageFormat,
      settings.fitToSinglePage,
    );

    // 分割ページ数を計算
    final pages = _calculatePages(adjustedLayout, pageFormat);

    // すべてのページを追加
    for (int pageIndex = 0; pageIndex < pages.length; pageIndex++) {
      final pageArea = pages[pageIndex];

      pdf.addPage(
        pw.Page(
          pageFormat: pageFormat,
          build: (pw.Context context) {
            return pw.Stack(
              children: [
                // ヘッダー（タイトル）
                if (settings.title.isNotEmpty)
                  pw.Positioned(
                    top: 20,
                    left: 0,
                    right: 0,
                    child: pw.Center(
                      child: pw.Text(
                        settings.title,
                        style: pw.TextStyle(
                          font: font,
                          fontSize: 18,
                          fontWeight: pw.FontWeight.bold,
                        ),
                      ),
                    ),
                  ),

                // フッター（日付）
                if (settings.showDate)
                  pw.Positioned(
                    bottom: 20,
                    left: 0,
                    right: 0,
                    child: pw.Center(
                      child: pw.Text(
                        '出力日: ${DateFormat('yyyy年MM月dd日').format(DateTime.now())}',
                        style: pw.TextStyle(
                          font: font,
                          fontSize: 9,
                          color: PdfColors.grey700,
                        ),
                      ),
                    ),
                  ),

                // 家系図本体
                pw.Positioned(
                  left: 0,
                  top: 50,
                  child: pw.Container(
                    width: pageFormat.width,
                    height: pageFormat.height - 80,
                    child: _buildTreeContent(
                      adjustedLayout,
                      pageArea,
                      font,
                    ),
                  ),
                ),

                // ページ番号
                if (pages.length > 1)
                  pw.Positioned(
                    bottom: 20,
                    right: 20,
                    child: pw.Text(
                      '${pageIndex + 1}/${pages.length}',
                      style: pw.TextStyle(
                        font: font,
                        fontSize: 9,
                        color: PdfColors.grey700,
                      ),
                    ),
                  ),

                // 凡例
                if (settings.showLegend && pageIndex == 0)
                  pw.Positioned(
                    bottom: 40,
                    left: 20,
                    child: _buildLegend(font),
                  ),
              ],
            );
          },
        ),
      );
    }

    // PDFを生成して返す
    return pdf.save();
  }

  // 家系図のレイアウトを調整
  TreeLayout _adjustLayoutForPdf(
    TreeLayout originalLayout,
    PdfPageFormat pageFormat,
    bool fitToSinglePage,
  ) {
    if (!fitToSinglePage) {
      // そのまま返す（複数ページに分割）
      return originalLayout;
    }

    // 利用可能な描画領域
    final availableWidth = pageFormat.width - 40; // マージン
    final availableHeight = pageFormat.height - 100; // タイトル・フッター用のスペース

    // 元のレイアウトサイズ
    final originalWidth = originalLayout.requiredSize.width;
    final originalHeight = originalLayout.requiredSize.height;

    // スケール計算（幅と高さの両方に収まる最大値）
    final scaleX = availableWidth / originalWidth;
    final scaleY = availableHeight / originalHeight;
    final scale = scaleX < scaleY ? scaleX : scaleY;

    // 人物ノードを再配置
    final scaledPersons = originalLayout.positionedPersons.map((person) {
      return PositionedPerson(
        person: person.person,
        position: Offset(
          person.position.dx * scale,
          person.position.dy * scale,
        ),
        size: Size(
          person.size.width * scale,
          person.size.height * scale,
        ),
        generation: person.generation,
      );
    }).toList();

    // 関係線を再配置
    final scaledRelationships = originalLayout.positionedRelationships.map((rel) {
      return PositionedRelationship(
        relationship: rel.relationship,
        pathPoints: rel.pathPoints.map((point) {
          return Offset(point.dx * scale, point.dy * scale);
        }).toList(),
      );
    }).toList();

    // 調整後のレイアウトを返す
    return TreeLayout(
      positionedPersons: scaledPersons,
      positionedRelationships: scaledRelationships,
      requiredSize: Size(
        originalWidth * scale,
        originalHeight * scale,
      ),
    );
  }

  // ページ分割を計算
  List<Rect> _calculatePages(TreeLayout layout, PdfPageFormat pageFormat) {
    final contentWidth = layout.requiredSize.width;
    final contentHeight = layout.requiredSize.height;

    // 利用可能な描画領域
    final availableWidth = pageFormat.width - 40; // マージン
    final availableHeight = pageFormat.height - 100; // タイトル・フッター用のスペース

    // 必要なページ数を計算
    final horizontalPages = (contentWidth / availableWidth).ceil();
    final verticalPages = (contentHeight / availableHeight).ceil();

    final List<Rect> pages = [];

    for (int y = 0; y < verticalPages; y++) {
      for (int x = 0; x < horizontalPages; x++) {
        final left = x * availableWidth;
        final top = y * availableHeight;
        final width = (x + 1) * availableWidth > contentWidth
            ? contentWidth - x * availableWidth
            : availableWidth;
        final height = (y + 1) * availableHeight > contentHeight
            ? contentHeight - y * availableHeight
            : availableHeight;

        pages.add(Rect.fromLTWH(left, top, width, height));
      }
    }

    return pages;
  }

  // 家系図コンテンツを構築
  pw.Widget _buildTreeContent(
    TreeLayout layout,
    Rect pageArea,
    pw.Font? font,
  ) {
    return pw.CustomPaint(
      painter: (pw.PdfGraphics canvas, pw.Size size) {
        // 原点をページエリアの左上に移動
        canvas.translate(-pageArea.left, -pageArea.top);

        // 関係線を描画
        for (final relationship in layout.positionedRelationships) {
          final points = relationship.pathPoints;
          if (points.isEmpty) continue;

          // 線のスタイル設定
          canvas.setStrokeColor(
            relationship.relationship.type == RelationType.parentChild
                ? PdfColors.blue700
                : PdfColors.pink700,
          );
          canvas.setLineWidth(1);

          // 親子関係は実線、配偶者関係は点線
          if (relationship.relationship.type == RelationType.parentChild) {
            // 実線パスの描画
            canvas.moveTo(points.first.dx, points.first.dy);
            for (int i = 1; i < points.length; i++) {
              canvas.lineTo(points[i].dx, points[i].dy);
            }
            canvas.strokePath();
          } else {
            // 点線の描画
            for (int i = 0; i < points.length - 1; i++) {
              _drawDashedLine(
                canvas,
                points[i],
                points[i + 1],
                dashLength: 3,
                gapLength: 3,
              );
            }
          }
        }

        // 人物ノードを描画
        for (final person in layout.positionedPersons) {
          final rect = PdfRect.fromLTWH(
            person.position.dx,
            person.position.dy,
            person.size.width,
            person.size.height,
          );

          // ノードがページ領域と交差するか確認
          if (!_rectIntersectsWithPage(rect, pageArea)) {
            continue; // このページには表示されない
          }

          // ノード背景
          canvas.setFillColor(PdfColors.white);
          canvas.drawRect(rect, 0, 0, 2, 2);
          canvas.fillPath();

          // ノード枠線
          final borderColor = person.person.gender == Gender.male
              ? PdfColors.blue700
              : person.person.gender == Gender.female
                  ? PdfColors.pink700
                  : PdfColors.grey700;
          canvas.setStrokeColor(borderColor);
          canvas.setLineWidth(1);
          canvas.drawRect(rect, 0, 0, 2, 2);
          canvas.strokePath();

          // 名前テキスト
          final textX = person.position.dx + person.size.width / 2;
          final textY = person.position.dy + 15;
          
          _drawCenteredText(
            canvas, 
            person.person.name, 
            textX, 
            textY, 
            font: font, 
            fontSize: 10,
            fontWeight: pw.FontWeight.bold,
          );

          // 生没年テキスト
          if (person.person.birthDate != null || person.person.deathDate != null) {
            String dateText = '';
            if (person.person.birthDate != null) {
              dateText = '${person.person.birthDate!.year}年';
              if (person.person.deathDate != null) {
                dateText += ' 〜 ${person.person.deathDate!.year}年';
              } else {
                dateText += ' 〜';
              }
            } else if (person.person.deathDate != null) {
              dateText = '? 〜 ${person.person.deathDate!.year}年';
            }

            _drawCenteredText(
              canvas, 
              dateText, 
              textX, 
              textY + 15, 
              font: font, 
              fontSize: 8,
              color: PdfColors.grey700,
            );
          }
        }
      },
    );
  }

  // 点線を描画するヘルパーメソッド
  void _drawDashedLine(
    pw.PdfGraphics canvas,
    Offset p1,
    Offset p2, {
    double dashLength = 3,
    double gapLength = 3,
  }) {
    final dx = p2.dx - p1.dx;
    final dy = p2.dy - p1.dy;
    final distance = sqrt(dx * dx + dy * dy);
    final unitX = dx / distance;
    final unitY = dy / distance;

    var currentDistance = 0.0;
    
    while (currentDistance < distance) {
      final startX = p1.dx + unitX * currentDistance;
      final startY = p1.dy + unitY * currentDistance;
      
      currentDistance += dashLength;
      if (currentDistance > distance) {
        currentDistance = distance;
      }
      
      final endX = p1.dx + unitX * currentDistance;
      final endY = p1.dy + unitY * currentDistance;
      
      canvas.moveTo(startX, startY);
      canvas.lineTo(endX, endY);
      canvas.strokePath();
      
      currentDistance += gapLength;
    }
  }

  // 矩形がページ領域と交差するか確認するヘルパーメソッド
  bool _rectIntersectsWithPage(PdfRect rect, Rect pageArea) {
    return rect.right >= pageArea.left &&
        rect.left <= pageArea.right &&
        rect.bottom >= pageArea.top &&
        rect.top <= pageArea.bottom;
  }

  // 中央揃えのテキストを描画するヘルパーメソッド
  void _drawCenteredText(
    pw.PdfGraphics canvas, 
    String text, 
    double x, 
    double y, {
    pw.Font? font,
    double fontSize = 12,
    pw.FontWeight fontWeight = pw.FontWeight.normal,
    PdfColor color = PdfColors.black,
  }) {
    final textSpan = pw.TextSpan(
      text: text,
      style: pw.TextStyle(
        font: font,
        fontSize: fontSize,
        fontWeight: fontWeight,
        color: color,
      ),
    );
    
    final textPainter = pw.TextPainter(
      text: textSpan,
      textAlign: pw.TextAlign.center,
      textDirection: pw.TextDirection.ltr,
    );
    
    textPainter.layout();
    
    final textWidth = textPainter.width;
    final textX = x - textWidth / 2;
    
    textPainter.paint(canvas, pw.Offset(textX, y));
  }

  // 凡例を構築
  pw.Widget _buildLegend(pw.Font? font) {
    return pw.Container(
      padding: const pw.EdgeInsets.all(5),
      decoration: pw.BoxDecoration(
        color: PdfColors.white,
        border: pw.Border.all(color: PdfColors.grey300),
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(4)),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            '凡例',
            style: pw.TextStyle(
              font: font,
              fontSize: 9,
              fontWeight: pw.FontWeight.bold,
            ),
          ),
          pw.SizedBox(height: 3),
          pw.Row(
            children: [
              pw.Container(
                width: 12,
                height: 12,
                decoration: pw.BoxDecoration(
                  border: pw.Border.all(color: PdfColors.blue700),
                  borderRadius: const pw.BorderRadius.all(pw.Radius.circular(2)),
                ),
              ),
              pw.SizedBox(width: 5),
              pw.Text(
                '男性',
                style: pw.TextStyle(
                  font: font,
                  fontSize: 8,
                ),
              ),
              pw.SizedBox(width: 10),
              pw.Container(
                width: 12,
                height: 12,
                decoration: pw.BoxDecoration(
                  border: pw.Border.all(color: PdfColors.pink700),
                  borderRadius: const pw.BorderRadius.all(pw.Radius.circular(2)),
                ),
              ),
              pw.SizedBox(width: 5),
              pw.Text(
                '女性',
                style: pw.TextStyle(
                  font: font,
                  fontSize: 8,
                ),
              ),
            ],
          ),
          pw.SizedBox(height: 3),
          pw.Row(
            children: [
              pw.Container(
                width: 20,
                height: 2,
                color: PdfColors.blue700,
              ),
              pw.SizedBox(width: 5),
              pw.Text(
                '親子関係',
                style: pw.TextStyle(
                  font: font,
                  fontSize: 8,
                ),
              ),
              pw.SizedBox(width: 10),
              pw.Container(
                width: 20,
                child: pw.CustomPaint(
                  painter: (pw.PdfGraphics canvas, pw.Size size) {
                    canvas.setStrokeColor(PdfColors.pink700);
                    canvas.setLineWidth(1);
                    _drawDashedLine(
                      canvas,
                      Offset(0, size.height / 2),
                      Offset(size.width, size.height / 2),
                      dashLength: 2,
                      gapLength: 2,
                    );
                  },
                  size: const pw.Size(20, 2),
                ),
              ),
              pw.SizedBox(width: 5),
              pw.Text(
                '配偶者関係',
                style: pw.TextStyle(
                  font: font,
                  fontSize: 8,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  // 数学的なsqrt関数
  double sqrt(double value) {
    return value.sqrt;
  }
}
```

### 2.3 PDF出力サービス

#### PdfExportService クラス

PDFファイルの生成と保存・共有を担当するサービスクラスです。

```dart
// lib/features/pdf_export/services/pdf_export_service.dart
import 'dart:typed_data';
import 'package:chart_my_roots_app/features/pdf_export/models/pdf_settings.dart';
import 'package:chart_my_roots_app/features/pdf_export/services/family_tree_pdf_generator.dart';
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:path_provider/path_provider.dart';
import 'package:universal_html/html.dart' as html;
import 'dart:io' as io;
import 'package:share_plus/share_plus.dart';

class PdfExportService {
  // 日本語フォントデータの取得
  Future<Uint8List?> _loadJapaneseFont() async {
    try {
      // アセットからフォントをロード
      return await rootBundle.load('assets/fonts/NotoSansJP-Regular.ttf').then((data) => data.buffer.asUint8List());
    } catch (e) {
      return null; // フォントが見つからなければnullを返す
    }
  }

  // PDFを生成
  Future<Uint8List> generatePdf({
    required FamilyTreeData familyTreeData,
    required PdfSettings settings,
  }) async {
    final japaneseFontData = await _loadJapaneseFont();
    
    final generator = FamilyTreePdfGenerator(
      japaneseFontData: japaneseFontData,
    );
    
    return await generator.generatePdf(
      familyTreeData: familyTreeData,
      settings: settings,
    );
  }

  // PDFをダウンロード（Web）
  Future<void> downloadPdf(Uint8List pdfData, String fileName) async {
    if (kIsWeb) {
      final blob = html.Blob([pdfData], 'application/pdf');
      final url = html.Url.createObjectUrlFromBlob(blob);
      
      final anchor = html.AnchorElement(href: url)
        ..setAttribute('download', fileName)
        ..click();
      
      html.Url.revokeObjectUrl(url);
    } else {
      // モバイル/デスクトップの場合、一時ファイルに保存して共有
      final directory = await getTemporaryDirectory();
      final path = '${directory.path}/$fileName';
      final file = io.File(path);
      await file.writeAsBytes(pdfData);
      
      await Share.shareXFiles([XFile(path)], text: 'ここに家系図PDFがあります');
    }
  }

  // PDFプレビュー用の画像を生成
  Future<Uint8List?> generatePdfPreview({
    required FamilyTreeData familyTreeData,
    required PdfSettings settings,
  }) async {
    // 実装は省略
    // pdf_render パッケージなどを使用してPDFの最初のページを画像として取得
    return null;
  }
}
```

## 3. 状態管理（Riverpod）

### 3.1 PDF設定の状態管理

```dart
// lib/features/pdf_export/application/pdf_settings_controller.dart
import 'package:chart_my_roots_app/features/pdf_export/models/pdf_settings.dart';
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// PDF設定プロバイダ
final pdfSettingsProvider = StateNotifierProvider<PdfSettingsNotifier, PdfSettings>((ref) {
  final selectedTree = ref.watch(selectedFamilyTreeStreamProvider).value;
  
  final String initialTitle = selectedTree != null
      ? '家系図 - ${selectedTree.name}'
      : '家系図';
  
  return PdfSettingsNotifier(
    PdfSettings(title: initialTitle),
  );
});

class PdfSettingsNotifier extends StateNotifier<PdfSettings> {
  PdfSettingsNotifier(PdfSettings initialState) : super(initialState);
  
  void updateTitle(String title) {
    state = state.copyWith(title: title);
  }
  
  void updatePageFormat(PdfPageFormat pageFormat) {
    state = state.copyWith(pageFormat: pageFormat);
  }
  
  void updateOrientation(PdfOrientation orientation) {
    state = state.copyWith(orientation: orientation);
  }
  
  void updateShowDate(bool showDate) {
    state = state.copyWith(showDate: showDate);
  }
  
  void updateShowLegend(bool showLegend) {
    state = state.copyWith(showLegend: showLegend);
  }
  
  void updateFitToSinglePage(bool fitToSinglePage) {
    state = state.copyWith(fitToSinglePage: fitToSinglePage);
  }
  
  void reset(FamilyTreeData? familyTreeData) {
    final String title = familyTreeData != null
        ? '家系図 - ${familyTreeData.name}'
        : '家系図';
    
    state = PdfSettings(title: title);
  }
}
```

### 3.2 PDF生成処理の状態管理

```dart
// lib/features/pdf_export/application/pdf_export_controller.dart
import 'dart:typed_data';
import 'package:chart_my_roots_app/features/pdf_export/models/pdf_settings.dart';
import 'package:chart_my_roots_app/features/pdf_export/services/pdf_export_service.dart';
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// PDF出力サービスプロバイダ
final pdfExportServiceProvider = Provider<PdfExportService>((ref) {
  return PdfExportService();
});

// PDF生成状態プロバイダ
final pdfGenerationStateProvider = StateNotifierProvider<PdfGenerationNotifier, PdfGenerationState>((ref) {
  return PdfGenerationNotifier();
});

// PDF生成状態
class PdfGenerationState {
  final bool isGenerating;
  final bool isComplete;
  final String? errorMessage;
  final Uint8List? pdfData;
  
  PdfGenerationState({
    this.isGenerating = false,
    this.isComplete = false,
    this.errorMessage,
    this.pdfData,
  });
  
  PdfGenerationState copyWith({
    bool? isGenerating,
    bool? isComplete,
    String? errorMessage,
    Uint8List? pdfData,
  }) {
    return PdfGenerationState(
      isGenerating: isGenerating ?? this.isGenerating,
      isComplete: isComplete ?? this.isComplete,
      errorMessage: errorMessage,
      pdfData: pdfData ?? this.pdfData,
    );
  }
}

class PdfGenerationNotifier extends StateNotifier<PdfGenerationState> {
  PdfGenerationNotifier() : super(PdfGenerationState());
  
  void reset() {
    state = PdfGenerationState();
  }
  
  Future<void> generatePdf({
    required PdfExportService service,
    required FamilyTreeData familyTreeData,
    required PdfSettings settings,
  }) async {
    try {
      state = PdfGenerationState(isGenerating: true);
      
      final pdfData = await service.generatePdf(
        familyTreeData: familyTreeData,
        settings: settings,
      );
      
      state = PdfGenerationState(
        isGenerating: false,
        isComplete: true,
        pdfData: pdfData,
      );
    } catch (e) {
      state = PdfGenerationState(
        isGenerating: false,
        isComplete: false,
        errorMessage: 'PDF生成中にエラーが発生しました: $e',
      );
    }
  }
  
  Future<void> downloadPdf({
    required PdfExportService service,
    required String fileName,
  }) async {
    if (state.pdfData == null) {
      state = state.copyWith(
        errorMessage: 'PDFデータが見つかりません',
      );
      return;
    }
    
    try {
      await service.downloadPdf(state.pdfData!, fileName);
    } catch (e) {
      state = state.copyWith(
        errorMessage: 'PDFのダウンロード中にエラーが発生しました: $e',
      );
    }
  }
}
```

## 4. UI実装

### 4.1 PDF設定ダイアログ

```dart
// lib/features/pdf_export/presentation/dialogs/pdf_settings_dialog.dart
import 'package:chart_my_roots_app/features/pdf_export/application/pdf_export_controller.dart';
import 'package:chart_my_roots_app/features/pdf_export/application/pdf_settings_controller.dart';
import 'package:chart_my_roots_app/features/pdf_export/models/pdf_settings.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:pdf/pdf.dart';

class PdfSettingsDialog extends ConsumerWidget {
  const PdfSettingsDialog({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 現在のPDF設定
    final pdfSettings = ref.watch(pdfSettingsProvider);
    
    // PDF生成状態
    final pdfGenerationState = ref.watch(pdfGenerationStateProvider);
    
    return AlertDialog(
      title: Text('PDF出力設定'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // タイトル設定
            TextFormField(
              initialValue: pdfSettings.title,
              decoration: InputDecoration(
                labelText: 'タイトル',
                hintText: 'PDFに表示するタイトル',
              ),
              onChanged: (value) {
                ref.read(pdfSettingsProvider.notifier).updateTitle(value);
              },
            ),
            
            SizedBox(height: 16),
            
            // 用紙サイズ設定
            Text('用紙サイズ', style: TextStyle(fontWeight: FontWeight.bold)),
            RadioListTile<PdfPageFormat>(
              title: Text('A4'),
              value: PdfPageFormat.a4,
              groupValue: pdfSettings.pageFormat,
              onChanged: (value) {
                if (value != null) {
                  ref.read(pdfSettingsProvider.notifier).updatePageFormat(value);
                }
              },
            ),
            RadioListTile<PdfPageFormat>(
              title: Text('A3'),
              value: PdfPageFormat.a3,
              groupValue: pdfSettings.pageFormat,
              onChanged: (value) {
                if (value != null) {
                  ref.read(pdfSettingsProvider.notifier).updatePageFormat(value);
                }
              },
            ),
            RadioListTile<PdfPageFormat>(
              title: Text('レターサイズ'),
              value: PdfPageFormat.letter,
              groupValue: pdfSettings.pageFormat,
              onChanged: (value) {
                if (value != null) {
                  ref.read(pdfSettingsProvider.notifier).updatePageFormat(value);
                }
              },
            ),
            
            SizedBox(height: 16),
            
            // 向き設定
            Text('向き', style: TextStyle(fontWeight: FontWeight.bold)),
            Row(
              children: [
                Expanded(
                  child: RadioListTile<PdfOrientation>(
                    title: Text('縦向き'),
                    value: PdfOrientation.portrait,
                    groupValue: pdfSettings.orientation,
                    onChanged: (value) {
                      if (value != null) {
                        ref.read(pdfSettingsProvider.notifier).updateOrientation(value);
                      }
                    },
                  ),
                ),
                Expanded(
                  child: RadioListTile<PdfOrientation>(
                    title: Text('横向き'),
                    value: PdfOrientation.landscape,
                    groupValue: pdfSettings.orientation,
                    onChanged: (value) {
                      if (value != null) {
                        ref.read(pdfSettingsProvider.notifier).updateOrientation(value);
                      }
                    },
                  ),
                ),
              ],
            ),
            
            // プレビュー表示
            SizedBox(height: 16),
            Center(
              child: Container(
                width: 150,
                height: 180,
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey),
                ),
                child: Center(
                  child: AspectRatio(
                    aspectRatio: pdfSettings.orientation == PdfOrientation.portrait
                        ? 1 / 1.414  // A4比率
                        : 1.414 / 1,
                    child: Container(
                      color: Colors.white,
                      child: Stack(
                        children: [
                          // タイトル
                          Positioned(
                            top: 10,
                            left: 0,
                            right: 0,
                            child: Center(
                              child: Text(
                                'タイトル',
                                style: TextStyle(fontSize: 8),
                              ),
                            ),
                          ),
                          
                          // 家系図プレースホルダー
                          Center(
                            child: Container(
                              width: 60,
                              height: 40,
                              decoration: BoxDecoration(
                                border: Border.all(color: Colors.grey),
                              ),
                              child: Center(
                                child: Text(
                                  '家系図',
                                  style: TextStyle(fontSize: 6),
                                ),
                              ),
                            ),
                          ),
                          
                          // フッター
                          if (pdfSettings.showDate)
                            Positioned(
                              bottom: 5,
                              left: 0,
                              right: 0,
                              child: Center(
                                child: Text(
                                  '日付',
                                  style: TextStyle(fontSize: 6),
                                ),
                              ),
                            ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
            
            SizedBox(height: 16),
            
            // 表示オプション
            Text('表示オプション', style: TextStyle(fontWeight: FontWeight.bold)),
            CheckboxListTile(
              title: Text('日付を表示'),
              value: pdfSettings.showDate,
              onChanged: (value) {
                if (value != null) {
                  ref.read(pdfSettingsProvider.notifier).updateShowDate(value);
                }
              },
              controlAffinity: ListTileControlAffinity.leading,
              dense: true,
            ),
            CheckboxListTile(
              title: Text('凡例を表示'),
              value: pdfSettings.showLegend,
              onChanged: (value) {
                if (value != null) {
                  ref.read(pdfSettingsProvider.notifier).updateShowLegend(value);
                }
              },
              controlAffinity: ListTileControlAffinity.leading,
              dense: true,
            ),
            CheckboxListTile(
              title: Text('1ページに収める'),
              subtitle: Text('大きな家系図は縮小されます'),
              value: pdfSettings.fitToSinglePage,
              onChanged: (value) {
                if (value != null) {
                  ref.read(pdfSettingsProvider.notifier).updateFitToSinglePage(value);
                }
              },
              controlAffinity: ListTileControlAffinity.leading,
              dense: true,
            ),
            
            // エラーメッセージ
            if (pdfGenerationState.errorMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 16.0),
                child: Text(
                  pdfGenerationState.errorMessage!,
                  style: TextStyle(color: Colors.red),
                ),
              ),
            
            // 生成中インジケーター
            if (pdfGenerationState.isGenerating)
              Padding(
                padding: const EdgeInsets.only(top: 16.0),
                child: Center(
                  child: Column(
                    children: [
                      CircularProgressIndicator(),
                      SizedBox(height: 8),
                      Text('PDFを生成中...'),
                    ],
                  ),
                ),
              ),
          ],
        ),
      ),
      actions: [
        // キャンセルボタン
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
          },
          child: Text('キャンセル'),
        ),
        
        // プレビューボタン
        TextButton(
          onPressed: pdfGenerationState.isGenerating
              ? null
              : () async {
                  final selectedTree = ref.read(selectedFamilyTreeStreamProvider).value;
                  if (selectedTree == null) {
                    return;
                  }
                  
                  final service = ref.read(pdfExportServiceProvider);
                  final settings = ref.read(pdfSettingsProvider);
                  
                  await ref.read(pdfGenerationStateProvider.notifier).generatePdf(
                    service: service,
                    familyTreeData: selectedTree,
                    settings: settings,
                  );
                  
                  if (!context.mounted) return;
                  
                  // プレビューダイアログを表示
                  if (pdfGenerationState.pdfData != null) {
                    Navigator.of(context).pop();
                    showDialog(
                      context: context,
                      builder: (context) => PdfPreviewDialog(),
                    );
                  }
                },
          child: Text('プレビュー'),
        ),
        
        // 生成ボタン
        ElevatedButton(
          onPressed: pdfGenerationState.isGenerating
              ? null
              : () async {
                  final selectedTree = ref.read(selectedFamilyTreeStreamProvider).value;
                  if (selectedTree == null) {
                    return;
                  }
                  
                  final service = ref.read(pdfExportServiceProvider);
                  final settings = ref.read(pdfSettingsProvider);
                  
                  await ref.read(pdfGenerationStateProvider.notifier).generatePdf(
                    service: service,
                    familyTreeData: selectedTree,
                    settings: settings,
                  );
                  
                  if (!context.mounted) return;
                  
                  if (pdfGenerationState.pdfData != null) {
                    // ファイル名の生成
                    final timestamp = DateTime.now().millisecondsSinceEpoch;
                    final fileName = 'family_tree_${timestamp}.pdf';
                    
                    await ref.read(pdfGenerationStateProvider.notifier).downloadPdf(
                      service: service,
                      fileName: fileName,
                    );
                    
                    Navigator.of(context).pop();
                  }
                },
          child: Text('PDFを生成'),
        ),
      ],
    );
  }
}
```

### 4.2 PDFプレビューダイアログ

```dart
// lib/features/pdf_export/presentation/dialogs/pdf_preview_dialog.dart
import 'package:chart_my_roots_app/features/pdf_export/application/pdf_export_controller.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:printing/printing.dart';

class PdfPreviewDialog extends ConsumerWidget {
  const PdfPreviewDialog({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final pdfGenerationState = ref.watch(pdfGenerationStateProvider);
    final pdfExportService = ref.watch(pdfExportServiceProvider);
    
    return Dialog(
      child: Container(
        width: double.infinity,
        height: 500,
        padding: EdgeInsets.all(16),
        child: Column(
          children: [
            // ヘッダー
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'PDFプレビュー',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.close),
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                ),
              ],
            ),
            
            Divider(),
            
            // プレビュー表示
            Expanded(
              child: pdfGenerationState.pdfData != null
                  ? PdfPreview(
                      build: (format) => pdfGenerationState.pdfData!,
                      useActions: false,
                      canChangeOrientation: false,
                      canChangePageFormat: false,
                    )
                  : Center(
                      child: Text('プレビューできるPDFがありません'),
                    ),
            ),
            
            SizedBox(height: 16),
            
            // アクションボタン
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () {
                    Navigator.of(context).pop();
                  },
                  child: Text('閉じる'),
                ),
                SizedBox(width: 8),
                ElevatedButton(
                  onPressed: pdfGenerationState.pdfData != null
                      ? () async {
                          // ファイル名の生成
                          final timestamp = DateTime.now().millisecondsSinceEpoch;
                          final fileName = 'family_tree_${timestamp}.pdf';
                          
                          await ref.read(pdfGenerationStateProvider.notifier).downloadPdf(
                            service: pdfExportService,
                            fileName: fileName,
                          );
                          
                          if (!context.mounted) return;
                          Navigator.of(context).pop();
                        }
                      : null,
                  child: Text('ダウンロード'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
```

## 5. 日本語フォントの対応

### 5.1 フォントの組み込み

Flutter/Dartアプリケーションに日本語フォントを組み込み、PDFに適用します。

```yaml
# pubspec.yaml
flutter:
  assets:
    - assets/fonts/
    
  fonts:
    - family: NotoSansJP
      fonts:
        - asset: assets/fonts/NotoSansJP-Regular.ttf
        - asset: assets/fonts/NotoSansJP-Bold.ttf
          weight: 700
```

### 5.2 フォント読み込みユーティリティ

```dart
// lib/features/pdf_export/utils/font_loader.dart
import 'dart:typed_data';
import 'package:flutter/services.dart';

class FontLoader {
  static Future<Map<String, Uint8List>> loadPdfFonts() async {
    try {
      final Map<String, Uint8List> fonts = {};
      
      // 通常フォント
      fonts['regular'] = await rootBundle
          .load('assets/fonts/NotoSansJP-Regular.ttf')
          .then((data) => data.buffer.asUint8List());
      
      // 太字フォント
      fonts['bold'] = await rootBundle
          .load('assets/fonts/NotoSansJP-Bold.ttf')
          .then((data) => data.buffer.asUint8List());
      
      return fonts;
    } catch (e) {
      // エラーハンドリング
      return {};
    }
  }
}
```

## 6. 最適化

### 6.1 大規模家系図の対応

```dart
// lib/features/pdf_export/utils/pdf_optimization.dart
import 'package:chart_my_roots_app/features/family_tree/layout/tree_layout_engine.dart';

class PdfOptimization {
  // 大規模家系図の分割最適化
  static List<Rect> optimizePageSplit(TreeLayout layout, PdfPageFormat pageFormat) {
    // 人物数のチェック
    final int personCount = layout.positionedPersons.length;
    
    if (personCount <= 20) {
      // 少人数の場合は標準分割
      return calculateStandardPages(layout, pageFormat);
    } else if (personCount <= 50) {
      // 中規模の場合は最適化分割
      return calculateOptimizedPages(layout, pageFormat);
    } else {
      // 大規模の場合は世代単位で分割
      return calculateGenerationBasedPages(layout, pageFormat);
    }
  }
  
  // 標準的なページ分割
  static List<Rect> calculateStandardPages(TreeLayout layout, PdfPageFormat pageFormat) {
    // 実装は省略
    return [];
  }
  
  // 最適化されたページ分割
  static List<Rect> calculateOptimizedPages(TreeLayout layout, PdfPageFormat pageFormat) {
    // 実装は省略
    return [];
  }
  
  // 世代ベースのページ分割
  static List<Rect> calculateGenerationBasedPages(TreeLayout layout, PdfPageFormat pageFormat) {
    // 実装は省略
    return [];
  }
}
```

### 6.2 PDFファイルサイズの最適化

```dart
// lib/features/pdf_export/utils/pdf_compression.dart
import 'dart:typed_data';
import 'package:pdf/pdf.dart';

class PdfCompression {
  // PDFの圧縮設定
  static PdfPageFormat getOptimizedPageFormat(PdfPageFormat originalFormat, int personCount) {
    // 人物数に応じてDPIを調整
    double dpi = 300.0; // デフォルト
    
    if (personCount > 100) {
      dpi = 150.0; // 大規模家系図は解像度を下げる
    }
    
    return originalFormat.copyWith(
      marginAll: 20,
      raster: true,
      rasterDpi: dpi,
    );
  }
  
  // ファイルサイズ最適化
  static Future<Uint8List> compressPdf(Uint8List pdfData, {bool highQuality = true}) async {
    // 実際の圧縮処理は特定のライブラリに依存するため、ここでは実装を省略
    // デフォルトでは pdf パッケージ自体が最適化を行う
    return pdfData;
  }
}
```

## 7. エラーハンドリング

### 7.1 PDF生成例外

```dart
// lib/features/pdf_export/exceptions/pdf_exceptions.dart
// PDF出力に関連する例外クラス

// 基底例外クラス
class PdfException implements Exception {
  final String message;
  final dynamic originalError;
  
  PdfException(this.message, [this.originalError]);
  
  @override
  String toString() => 'PdfException: $message${originalError != null ? ' ($originalError)' : ''}';
}

// 具体的な例外クラス
class PdfGenerationException extends PdfException {
  PdfGenerationException([String message = 'PDF生成中にエラーが発生しました', dynamic originalError])
      : super(message, originalError);
}

class PdfDownloadException extends PdfException {
  PdfDownloadException([String message = 'PDFダウンロード中にエラーが発生しました', dynamic originalError])
      : super(message, originalError);
}

class PdfFontException extends PdfException {
  PdfFontException([String message = 'PDFフォント読み込み中にエラーが発生しました', dynamic originalError])
      : super(message, originalError);
}

class PdfSizeExceededException extends PdfException {
  PdfSizeExceededException([String message = 'PDFサイズが制限を超えています', dynamic originalError])
      : super(message, originalError);
}
```

### 7.2 エラーハンドリングユーティリティ

```dart
// lib/features/pdf_export/utils/pdf_error_handler.dart
import 'package:chart_my_roots_app/features/pdf_export/exceptions/pdf_exceptions.dart';
import 'package:flutter/material.dart';

class PdfErrorHandler {
  // 例外メッセージを取得
  static String getErrorMessage(dynamic error) {
    if (error is PdfException) {
      return error.message;
    } else if (error is Exception) {
      return 'エラーが発生しました: ${error.toString()}';
    } else {
      return '予期せぬエラーが発生しました';
    }
  }
  
  // エラーダイアログを表示
  static void showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('PDF出力エラー'),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: Text('閉じる'),
          ),
        ],
      ),
    );
  }
  
  // エラーのログ記録
  static void logError(String message, dynamic error) {
    // ロギングライブラリを使用（例：firebase_crashlytics, logger など）
    print('PDF ERROR: $message - $error');
  }
}
```

## 8. テスト計画

### 8.1 PDF生成のユニットテスト

```dart
// test/features/pdf_export/services/family_tree_pdf_generator_test.dart
import 'package:chart_my_roots_app/features/pdf_export/models/pdf_settings.dart';
import 'package:chart_my_roots_app/features/pdf_export/services/family_tree_pdf_generator.dart';
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/models/person.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('FamilyTreePdfGenerator Tests', () {
    late FamilyTreeData testFamilyTree;
    late PdfSettings testSettings;
    late FamilyTreePdfGenerator generator;
    
    setUp(() {
      // テスト用の家系図データを作成
      testFamilyTree = FamilyTreeData(
        id: 'test_tree',
        name: 'Test Family Tree',
        persons: [
          Person(
            id: 'p1',
            name: 'Test Person 1',
            gender: Gender.male,
          ),
          Person(
            id: 'p2',
            name: 'Test Person 2',
            gender: Gender.female,
          ),
        ],
        relationships: [],
        lastModified: DateTime.now(),
      );
      
      // テスト用の設定
      testSettings = PdfSettings(
        title: 'Test PDF',
        showDate: true,
        showLegend: true,
      );
      
      // ジェネレーターインスタンス
      generator = FamilyTreePdfGenerator();
    });
    
    test('generatePdf produces non-empty PDF data', () async {
      final pdfData = await generator.generatePdf(
        familyTreeData: testFamilyTree,
        settings: testSettings,
      );
      
      expect(pdfData, isNotNull);
      expect(pdfData.length, greaterThan(0));
    });
    
    test('_adjustLayoutForPdf scales layout correctly when fitToSinglePage is true', () {
      // 実装は省略 - 内部メソッドのテスト
    });
    
    test('_calculatePages creates correct number of pages', () {
      // 実装は省略 - 内部メソッドのテスト
    });
  });
}
```

### 8.2 PDFプレビューのウィジェットテスト

```dart
// test/features/pdf_export/presentation/dialogs/pdf_preview_dialog_test.dart
import 'package:chart_my_roots_app/features/pdf_export/application/pdf_export_controller.dart';
import 'package:chart_my_roots_app/features/pdf_export/presentation/dialogs/pdf_preview_dialog.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

// モッククラス
class MockPdfExportService extends Mock implements PdfExportService {}

void main() {
  testWidgets('PdfPreviewDialog shows preview when PDF data is available', (WidgetTester tester) async {
    // モックデータ設定
    final mockPdfData = Uint8List(10); // ダミーPDFデータ
    
    // プロバイダーオーバーライド
    final overrides = [
      pdfGenerationStateProvider.overrideWith((ref) => PdfGenerationState(
        isGenerating: false,
        isComplete: true,
        pdfData: mockPdfData,
      )),
      pdfExportServiceProvider.overrideWith((ref) => MockPdfExportService()),
    ];
    
    // ウィジェットをビルド
    await tester.pumpWidget(
      ProviderScope(
        overrides: overrides,
        child: MaterialApp(
          home: Scaffold(
            body: Builder(
              builder: (context) => ElevatedButton(
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (_) => PdfPreviewDialog(),
                  );
                },
                child: Text('Show Preview'),
              ),
            ),
          ),
        ),
      ),
    );
    
    // ダイアログを表示
    await tester.tap(find.text('Show Preview'));
    await tester.pumpAndSettle();
    
    // 検証
    expect(find.text('PDFプレビュー'), findsOneWidget);
    expect(find.text('プレビューできるPDFがありません'), findsNothing);
    expect(find.text('ダウンロード'), findsOneWidget);
  });
  
  // 他のテストケース
}
```

### 8.3 統合テスト

```dart
// integration_test/pdf_export_test.dart
import 'package:chart_my_roots_app/features/pdf_export/presentation/dialogs/pdf_settings_dialog.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  
  testWidgets('Complete PDF export flow', (WidgetTester tester) async {
    // アプリを起動
    await tester.pumpWidget(MyApp());
    
    // メイン画面に移動
    // ...
    
    // PDF出力ボタンをタップ
    await tester.tap(find.byIcon(Icons.picture_as_pdf));
    await tester.pumpAndSettle();
    
    // 設定ダイアログが表示されることを確認
    expect(find.byType(PdfSettingsDialog), findsOneWidget);
    
    // 設定を変更
    await tester.tap(find.text('横向き'));
    await tester.pumpAndSettle();
    
    // PDFを生成
    await tester.tap(find.text('PDFを生成'));
    await tester.pumpAndSettle();
    
    // 生成中表示が出ることを確認
    expect(find.text('PDFを生成中...'), findsOneWidget);
    
    // 生成完了を待つ
    // ここではテストの都合上、固定時間待機
    await Future.delayed(Duration(seconds: 2));
    await tester.pumpAndSettle();
    
    // ダイアログが閉じることを確認
    expect(find.byType(PdfSettingsDialog), findsNothing);
    
    // スナックバーメッセージを確認
    expect(find.text('PDFの生成が完了しました'), findsOneWidget);
  });
}
```

## 9. まとめ

PDF出力機能は、家系図を視覚的に共有・保存するための重要な機能です。この詳細設計では以下のポイントを重視しています：

1. **レイアウト最適化**
   - 家系図の構造をPDFに適したレイアウトに変換
   - 大規模家系図の場合は複数ページに分割
   - 1ページに収めるオプションによるスケーリング対応

2. **高品質な出力**
   - 日本語フォントの組み込み
   - 印刷に適した解像度設定
   - 凡例やタイトルなどの追加情報

3. **柔軟な設定オプション**
   - 用紙サイズ (A4, A3, レターサイズ)
   - 向き (縦向き/横向き)
   - 表示オプション (日付、凡例、1ページ表示)

4. **プラットフォーム対応**
   - Webではダウンロード機能
   - モバイル/デスクトップでは共有機能

5. **エラーハンドリング**
   - 適切な例外処理
   - ユーザーフレンドリーなエラーメッセージ

これらの設計により、ユーザーは家系図を高品質なPDFとして出力し、印刷や共有に活用できます。
