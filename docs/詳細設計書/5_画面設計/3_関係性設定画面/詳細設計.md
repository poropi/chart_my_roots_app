# 関係性設定画面 詳細設計書

## 1. 概要

関係性設定画面は、家系図内の人物間の関係（親子関係や配偶者関係）を設定・編集するためのモーダルダイアログです。既存の人物間の関係を視覚的に確認しながら新たな関係を追加したり、不要な関係を削除したりすることができます。Flutter/Dartでの実装を前提とした詳細設計を記載します。

## 2. 画面構成

### 2.1 画面レイアウト

```dart
// lib/features/relationship_editor/presentation/dialogs/relationship_dialog.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:chart_my_roots_app/features/relationship_editor/application/relationship_form_controller.dart';

class RelationshipDialog extends ConsumerWidget {
  final String fromPersonId;
  final String? relationshipId;
  
  const RelationshipDialog({
    Key? key,
    required this.fromPersonId,
    this.relationshipId,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 既存の関係性の編集か、新規追加かを判定
    final isNew = relationshipId == null;
    
    // フォームの初期化
    useEffect(() {
      if (isNew) {
        // 新規追加の場合
        ref.read(relationshipFormProvider.notifier).initNew(fromPersonId);
      } else {
        // 既存の関係性を編集する場合
        ref.read(relationshipFormProvider.notifier).initWithRelationship(
          relationshipId!,
          fromPersonId,
        );
      }
      return null;
    }, []);
    
    // フォームの状態を取得
    final formState = ref.watch(relationshipFormProvider);
    
    // 保存中の状態
    final isSaving = ref.watch(relationshipSavingProvider);
    
    // 現在選択中の人物（関係元）の情報を取得
    final fromPerson = ref.watch(personByIdProvider(fromPersonId));
    
    // 関係先候補の人物リストを取得（自分自身を除く）
    final availablePersons = ref.watch(availablePersonsProvider(fromPersonId));
    
    // ダイアログタイトル
    final title = isNew ? '関係性追加' : '関係性編集';
    
    return AlertDialog(
      title: Text(title),
      content: SingleChildScrollView(
        child: Container(
          width: double.maxFinite,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 基準となる人物の表示
              _buildPersonInfo(context, fromPerson.asData?.value),
              
              SizedBox(height: 16),
              
              // 関係タイプの選択
              Text(
                '関係タイプ',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.blueGrey,
                ),
              ),
              SizedBox(height: 8),
              _buildRelationTypeSelector(ref, formState.type),
              
              SizedBox(height: 16),
              
              // 関係を結ぶ相手の選択
              Text(
                '関係を結ぶ相手',
                style: TextStyle(
                  fontWeight: FontWeight.bold,
                  color: Colors.blueGrey,
                ),
              ),
              SizedBox(height: 8),
              _buildPersonSelector(
                context,
                ref,
                availablePersons.asData?.value ?? [],
                formState.toPersonId,
              ),
              
              SizedBox(height: 16),
              
              // 関係性プレビュー
              if (formState.toPersonId != null)
                _buildRelationshipPreview(
                  context,
                  ref,
                  fromPerson.asData?.value,
                  ref.watch(personByIdProvider(formState.toPersonId!)).asData?.value,
                  formState.type,
                ),
              
              // バリデーションエラーメッセージ
              if (ref.watch(relationshipFormErrorProvider) != null)
                Padding(
                  padding: const EdgeInsets.only(top: 16.0),
                  child: Text(
                    ref.watch(relationshipFormErrorProvider)!,
                    style: TextStyle(color: Colors.red),
                  ),
                ),
            ],
          ),
        ),
      ),
      actions: [
        // 削除ボタン（編集時のみ表示）
        if (!isNew)
          TextButton(
            onPressed: isSaving
                ? null
                : () => _confirmDelete(context, ref),
            child: Text(
              '関係削除',
              style: TextStyle(color: Colors.red),
            ),
          ),
        
        // スペーサー
        const Spacer(),
        
        // キャンセルボタン
        TextButton(
          onPressed: isSaving
              ? null
              : () {
                  Navigator.of(context).pop();
                },
          child: Text('キャンセル'),
        ),
        
        // 設定ボタン
        ElevatedButton(
          onPressed: isSaving || formState.toPersonId == null
              ? null
              : () => _saveRelationship(context, ref),
          child: isSaving
              ? SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                  ),
                )
              : Text('設定'),
        ),
      ],
    );
  }
  
  // 人物情報の表示
  Widget _buildPersonInfo(BuildContext context, Person? person) {
    if (person == null) {
      return SizedBox.shrink();
    }
    
    return Card(
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(8.0),
        child: Row(
          children: [
            // 性別に応じたアイコン
            Icon(
              person.gender == Gender.male
                  ? Icons.male
                  : person.gender == Gender.female
                      ? Icons.female
                      : Icons.person,
              color: person.gender == Gender.male
                  ? Colors.blue
                  : person.gender == Gender.female
                      ? Colors.pink
                      : Colors.grey,
              size: 32,
            ),
            SizedBox(width: 8),
            
            // 人物名
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    person.name,
                    style: TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  if (person.birthDate != null)
                    Text(
                      '${person.birthDate!.year}年生まれ',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey.shade600,
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  // 関係タイプ選択ウィジェット
  Widget _buildRelationTypeSelector(WidgetRef ref, RelationType type) {
    return Column(
      children: [
        RadioListTile<RelationType>(
          title: Text('親子関係'),
          subtitle: Text('選択した人物が相手の親になります'),
          value: RelationType.parentChild,
          groupValue: type,
          onChanged: (value) {
            if (value != null) {
              ref.read(relationshipFormProvider.notifier).updateType(value);
            }
          },
          dense: true,
          contentPadding: EdgeInsets.zero,
        ),
        RadioListTile<RelationType>(
          title: Text('配偶者関係'),
          subtitle: Text('選択した人物と相手が配偶者になります'),
          value: RelationType.spouse,
          groupValue: type,
          onChanged: (value) {
            if (value != null) {
              ref.read(relationshipFormProvider.notifier).updateType(value);
            }
          },
          dense: true,
          contentPadding: EdgeInsets.zero,
        ),
      ],
    );
  }
  
  // 関係を結ぶ相手の選択ウィジェット
  Widget _buildPersonSelector(
    BuildContext context,
    WidgetRef ref,
    List<Person> availablePersons,
    String? selectedPersonId,
  ) {
    if (availablePersons.isEmpty) {
      return Card(
        color: Colors.amber.shade50,
        child: Padding(
          padding: const EdgeInsets.all(8.0),
          child: Text(
            '関係を設定できる人物がいません。先に別の人物を追加してください。',
            style: TextStyle(color: Colors.amber.shade900),
          ),
        ),
      );
    }
    
    return DropdownButtonFormField<String>(
      decoration: InputDecoration(
        border: OutlineInputBorder(),
        hintText: '関係を結ぶ相手を選択',
        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      ),
      value: selectedPersonId,
      items: availablePersons.map((person) {
        return DropdownMenuItem<String>(
          value: person.id,
          child: Row(
            children: [
              Icon(
                person.gender == Gender.male
                    ? Icons.male
                    : person.gender == Gender.female
                        ? Icons.female
                        : Icons.person,
                color: person.gender == Gender.male
                    ? Colors.blue
                    : person.gender == Gender.female
                        ? Colors.pink
                        : Colors.grey,
                size: 16,
              ),
              SizedBox(width: 8),
              Expanded(
                child: Text(
                  person.name,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            ],
          ),
        );
      }).toList(),
      onChanged: (value) {
        if (value != null) {
          ref.read(relationshipFormProvider.notifier).updateToPersonId(value);
        }
      },
    );
  }
  
  // 関係性プレビューの表示
  Widget _buildRelationshipPreview(
    BuildContext context,
    WidgetRef ref,
    Person? fromPerson,
    Person? toPerson,
    RelationType type,
  ) {
    if (fromPerson == null || toPerson == null) {
      return SizedBox.shrink();
    }
    
    // 関係性の説明文
    String relationDescription;
    if (type == RelationType.parentChild) {
      relationDescription = '「${fromPerson.name}」は「${toPerson.name}」の親です';
    } else {
      relationDescription = '「${fromPerson.name}」と「${toPerson.name}」は配偶者です';
    }
    
    return Card(
      color: Colors.grey.shade100,
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '関係性プレビュー:',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 14,
              ),
            ),
            SizedBox(height: 12),
            
            // 関係性ダイアグラム
            _buildRelationshipDiagram(context, fromPerson, toPerson, type),
            
            SizedBox(height: 12),
            
            // 関係性の説明
            Text(
              relationDescription,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontStyle: FontStyle.italic,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  // 関係性ダイアグラムの表示
  Widget _buildRelationshipDiagram(
    BuildContext context,
    Person fromPerson,
    Person toPerson,
    RelationType type,
  ) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        // 関係元の人物
        _buildPersonCard(fromPerson),
        
        // 関係線
        Expanded(
          child: type == RelationType.parentChild
              ? _buildParentChildLine()
              : _buildSpouseLine(),
        ),
        
        // 関係先の人物
        _buildPersonCard(toPerson),
      ],
    );
  }
  
  // 人物カードの表示
  Widget _buildPersonCard(Person person) {
    return Container(
      width: 100,
      padding: EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border.all(
          color: person.gender == Gender.male
              ? Colors.blue
              : person.gender == Gender.female
                  ? Colors.pink
                  : Colors.grey,
          width: 2,
        ),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Column(
        children: [
          Text(
            person.name,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 12,
            ),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
  
  // 親子関係の線を表示
  Widget _buildParentChildLine() {
    return Stack(
      alignment: Alignment.center,
      children: [
        Container(
          height: 2,
          color: Colors.blue.shade700,
        ),
        Positioned(
          right: 0,
          child: Icon(
            Icons.arrow_forward,
            color: Colors.blue.shade700,
            size: 16,
          ),
        ),
        Positioned(
          top: -16,
          child: Container(
            padding: EdgeInsets.symmetric(horizontal: 4, vertical: 1),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(10),
              border: Border.all(color: Colors.grey.shade300),
            ),
            child: Text(
              '親',
              style: TextStyle(
                fontSize: 10,
                color: Colors.grey.shade700,
              ),
            ),
          ),
        ),
      ],
    );
  }
  
  // 配偶者関係の線を表示
  Widget _buildSpouseLine() {
    return Stack(
      alignment: Alignment.center,
      children: [
        CustomPaint(
          size: Size(double.infinity, 10),
          painter: DashedLinePainter(),
        ),
        Positioned(
          top: -16,
          child: Container(
            padding: EdgeInsets.symmetric(horizontal: 4, vertical: 1),
            decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: BorderRadius.circular(10),
              border: Border.all(color: Colors.grey.shade300),
            ),
            child: Text(
              '配偶者',
              style: TextStyle(
                fontSize: 10,
                color: Colors.grey.shade700,
              ),
            ),
          ),
        ),
      ],
    );
  }
  
  // 関係性の保存処理
  void _saveRelationship(BuildContext context, WidgetRef ref) async {
    try {
      // 保存中フラグをON
      ref.read(relationshipSavingProvider.notifier).state = true;
      
      // 関係性データを保存
      final controller = ref.read(relationshipControllerProvider);
      final formState = ref.read(relationshipFormProvider);
      
      if (relationshipId == null) {
        // 新規追加
        await controller.addRelationship(formState.toRelationship());
      } else {
        // 更新
        await controller.updateRelationship(formState.toRelationship());
      }
      
      if (context.mounted) {
        // ダイアログを閉じる
        Navigator.of(context).pop();
        
        // 成功メッセージ
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(relationshipId == null ? '関係性を追加しました' : '関係性を更新しました'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      // エラーメッセージを設定
      ref.read(relationshipFormErrorProvider.notifier).state = 
          '保存中にエラーが発生しました: ${e.toString()}';
    } finally {
      // 保存中フラグをOFF
      ref.read(relationshipSavingProvider.notifier).state = false;
    }
  }
  
  // 削除確認ダイアログ
  void _confirmDelete(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('関係性の削除'),
        content: Text('この関係性を削除してもよろしいですか？'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop(); // 確認ダイアログを閉じる
            },
            child: Text('キャンセル'),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            onPressed: () async {
              Navigator.of(context).pop(); // 確認ダイアログを閉じる
              
              try {
                // 保存中フラグをON
                ref.read(relationshipSavingProvider.notifier).state = true;
                
                // 関係性の削除処理
                final controller = ref.read(relationshipControllerProvider);
                
                if (relationshipId != null) {
                  await controller.deleteRelationship(relationshipId!);
                }
                
                if (context.mounted) {
                  // 編集ダイアログを閉じる
                  Navigator.of(context).pop();
                  
                  // 成功メッセージ
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('関係性を削除しました'),
                      backgroundColor: Colors.green,
                    ),
                  );
                }
              } catch (e) {
                // エラーメッセージを設定
                ref.read(relationshipFormErrorProvider.notifier).state = 
                    '削除中にエラーが発生しました: ${e.toString()}';
              } finally {
                // 保存中フラグをOFF
                ref.read(relationshipSavingProvider.notifier).state = false;
              }
            },
            child: Text('削除'),
          ),
        ],
      ),
    );
  }
}

// 点線を描画するためのカスタムペインター
class DashedLinePainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.pink.shade700
      ..strokeWidth = 2
      ..style = PaintingStyle.stroke;
    
    const dashWidth = 5;
    const dashSpace = 3;
    
    double startX = 0;
    final endX = size.width;
    
    while (startX < endX) {
      canvas.drawLine(
        Offset(startX, size.height / 2),
        Offset(startX + dashWidth, size.height / 2),
        paint,
      );
      startX += dashWidth + dashSpace;
    }
  }
  
  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
```

### 2.2 レスポンシブ対応

関係性設定画面もモーダルダイアログとして表示されるため、基本的なレスポンシブ対応として以下の対策を行います：

```dart
// lib/features/relationship_editor/presentation/dialogs/responsive_relationship_dialog.dart
import 'package:flutter/material.dart';

class ResponsiveRelationshipDialog extends StatelessWidget {
  final Widget child;
  
  const ResponsiveRelationshipDialog({
    Key? key,
    required this.child,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    // 画面サイズを取得
    final screenWidth = MediaQuery.of(context).size.width;
    
    // 小さい画面（モバイル）の場合は全画面に近いサイズで表示
    if (screenWidth < 600) {
      return Dialog(
        insetPadding: EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 24,
        ),
        child: child,
      );
    }
    
    // 大きい画面（タブレット、デスクトップ）の場合は適切なサイズに制限
    return Dialog(
      insetPadding: EdgeInsets.symmetric(
        horizontal: 40,
        vertical: 24,
      ),
      child: ConstrainedBox(
        constraints: BoxConstraints(
          maxWidth: 500,
        ),
        child: child,
      ),
    );
  }
}

// 使用例
void showRelationshipDialog(BuildContext context, {required String fromPersonId, String? relationshipId}) {
  showDialog(
    context: context,
    builder: (context) => ResponsiveRelationshipDialog(
      child: RelationshipDialog(
        fromPersonId: fromPersonId,
        relationshipId: relationshipId,
      ),
    ),
  );
}
```

## 3. 状態管理（Riverpod）

### 3.1 関係性フォームの状態管理

```dart
// lib/features/relationship_editor/application/relationship_form_controller.dart
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 関係性編集フォームの状態
class RelationshipFormState {
  final String? id;
  final String fromPersonId;
  final String? toPersonId;
  final RelationType type;
  
  RelationshipFormState({
    this.id,
    required this.fromPersonId,
    this.toPersonId,
    required this.type,
  });
  
  // 初期状態（新規追加用）
  factory RelationshipFormState.initial(String fromPersonId) {
    return RelationshipFormState(
      fromPersonId: fromPersonId,
      type: RelationType.parentChild,
    );
  }
  
  // 既存の関係性データからフォーム状態を作成
  factory RelationshipFormState.fromRelationship(Relationship relationship) {
    return RelationshipFormState(
      id: relationship.id,
      fromPersonId: relationship.fromPersonId,
      toPersonId: relationship.toPersonId,
      type: relationship.type,
    );
  }
  
  // フォーム状態からRelationshipモデルを作成
  Relationship toRelationship() {
    if (toPersonId == null) {
      throw Exception('Target person must be selected');
    }
    
    return Relationship(
      id: id ?? '',
      fromPersonId: fromPersonId,
      toPersonId: toPersonId!,
      type: type,
    );
  }
  
  // コピーメソッド
  RelationshipFormState copyWith({
    String? toPersonId,
    RelationType? type,
  }) {
    return RelationshipFormState(
      id: id,
      fromPersonId: fromPersonId,
      toPersonId: toPersonId ?? this.toPersonId,
      type: type ?? this.type,
    );
  }
}

// 関係性編集フォームの状態管理プロバイダ
final relationshipFormProvider = StateNotifierProvider<RelationshipFormNotifier, RelationshipFormState>((ref) {
  // 初期状態はダミー値で作成し、実際の初期化はダイアログ表示時に行う
  return RelationshipFormNotifier(RelationshipFormState.initial(''));
});

class RelationshipFormNotifier extends StateNotifier<RelationshipFormState> {
  final Ref? _ref;
  
  RelationshipFormNotifier(RelationshipFormState initialState, [this._ref])
      : super(initialState);
  
  // 新規追加用の初期化
  void initNew(String fromPersonId) {
    state = RelationshipFormState.initial(fromPersonId);
  }
  
  // 既存の関係性を編集するための初期化
  void initWithRelationship(String relationshipId, String fromPersonId) {
    if (_ref != null) {
      // リポジトリから関係性データを取得
      final relationshipsAsync = _ref!.read(relationshipsStreamProvider);
      
      if (relationshipsAsync.asData != null) {
        final relationships = relationshipsAsync.asData!.value;
        final relationship = relationships.firstWhere(
          (rel) => rel.id == relationshipId,
          orElse: () => Relationship(
            id: '',
            fromPersonId: fromPersonId,
            toPersonId: '',
            type: RelationType.parentChild,
          ),
        );
        
        state = RelationshipFormState.fromRelationship(relationship);
      } else {
        // データがまだロードされていない場合はダミー値で初期化
        state = RelationshipFormState.initial(fromPersonId);
      }
    } else {
      // _refがない場合（テスト時など）はダミー値で初期化
      state = RelationshipFormState.initial(fromPersonId);
    }
  }
  
  // フォームフィールドの更新メソッド
  void updateToPersonId(String toPersonId) {
    state = state.copyWith(toPersonId: toPersonId);
  }
  
  void updateType(RelationType type) {
    state = state.copyWith(type: type);
  }
}

// フォームエラーメッセージの状態プロバイダ
final relationshipFormErrorProvider = StateProvider<String?>((ref) => null);

// 保存中の状態プロバイダ
final relationshipSavingProvider = StateProvider<bool>((ref) => false);
```

### 3.2 人物選択用のプロバイダ

```dart
// lib/features/relationship_editor/application/person_selector_provider.dart
import 'package:chart_my_roots_app/models/person.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// IDで指定された人物を取得するプロバイダ
final personByIdProvider = Provider.family<AsyncValue<Person?>, String>((ref, personId) {
  final personsAsync = ref.watch(personsStreamProvider);
  
  return personsAsync.when(
    data: (persons) {
      final person = persons.firstWhere(
        (p) => p.id == personId,
        orElse: () => null,
      );
      return AsyncValue.data(person);
    },
    loading: () => const AsyncValue.loading(),
    error: (error, stack) => AsyncValue.error(error, stack),
  );
});

// 関係設定可能な人物リストを取得するプロバイダ
final availablePersonsProvider = Provider.family<AsyncValue<List<Person>>, String>((ref, fromPersonId) {
  final personsAsync = ref.watch(personsStreamProvider);
  
  return personsAsync.when(
    data: (persons) {
      // 自分自身を除外した人物リスト
      final availablePersons = persons
          .where((p) => p.id != fromPersonId)
          .toList();
      
      // 名前でソート
      availablePersons.sort((a, b) => a.name.compareTo(b.name));
      
      return AsyncValue.data(availablePersons);
    },
    loading: () => const AsyncValue.loading(),
    error: (error, stack) => AsyncValue.error(error, stack),
  );
});
```

### 3.3 関係性操作コントローラ

```dart
// lib/features/relationship_editor/application/relationship_controller.dart
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:chart_my_roots_app/repositories/relationship_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 関係性操作コントローラのプロバイダ
final relationshipControllerProvider = Provider<RelationshipController>((ref) {
  final repository = ref.watch(relationshipRepositoryProvider);
  return RelationshipController(repository);
});

// 関係性操作コントローラクラス
class RelationshipController {
  final RelationshipRepository _repository;
  
  RelationshipController(this._repository);
  
  // 関係性の追加
  Future<String> addRelationship(Relationship relationship) async {
    try {
      // 同じ人物間で同じ種類の関係が既に存在するかチェック
      final exists = await _checkDuplicateRelationship(relationship);
      if (exists) {
        throw Exception('この2人の間には既に同じ種類の関係が設定されています');
      }
      
      final newId = await _repository.addRelationship(relationship);
      return newId;
    } catch (e) {
      // エラーログ記録
      _logError('Failed to add relationship', e);
      rethrow;
    }
  }
  
  // 関係性の更新
  Future<void> updateRelationship(Relationship relationship) async {
    try {
      // 同じ人物間で同じ種類の関係が既に存在するかチェック（自分自身は除く）
      final exists = await _checkDuplicateRelationship(relationship, excludeId: relationship.id);
      if (exists) {
        throw Exception('この2人の間には既に同じ種類の関係が設定されています');
      }
      
      await _repository.updateRelationship(relationship);
    } catch (e) {
      // エラーログ記録
      _logError('Failed to update relationship', e);
      rethrow;
    }
  }
  
  // 関係性の削除
  Future<void> deleteRelationship(String id) async {
    try {
      await _repository.deleteRelationship(id);
    } catch (e) {
      // エラーログ記録
      _logError('Failed to delete relationship', e);
      rethrow;
    }
  }
  
  // 重複する関係性がないかチェック
  Future<bool> _checkDuplicateRelationship(
    Relationship relationship, {
    String? excludeId,
  }) async {
    final relationships = await _repository.getRelationshipsOnce();
    
    return relationships.any((rel) {
      // 自分自身は除外
      if (excludeId != null && rel.id == excludeId) {
        return false;
      }
      
      // 同じタイプの関係で、同じ人物同士の組み合わせをチェック
      if (rel.type != relationship.type) {
        return false;
      }
      
      // 親子関係の場合、方向が重要
      if (relationship.type == RelationType.parentChild) {
        return rel.fromPersonId == relationship.fromPersonId &&
               rel.toPersonId == relationship.toPersonId;
      }
      
      // 配偶者関係の場合、方向は関係ない
      return (rel.fromPersonId == relationship.fromPersonId &&
              rel.toPersonId == relationship.toPersonId) ||
             (rel.fromPersonId == relationship.toPersonId &&
              rel.toPersonId == relationship.fromPersonId);
    });
  }
  
  // エラーログ記録（実際の実装ではロギングライブラリを使用）
  void _logError(String message, dynamic error) {
    print('ERROR: $message - $error');
  }
}
```

## 4. バリデーション

### 4.1 関係性のバリデーション

```dart
// lib/features/relationship_editor/utils/validators.dart
import 'package:chart_my_roots_app/features/relationship_editor/application/relationship_form_controller.dart';
import 'package:chart_my_roots_app/models/relationship.dart';

class RelationshipValidators {
  // 関係先の人物が選択されているかを確認
  static String? validateToPersonId(String? value) {
    if (value == null || value.isEmpty) {
      return '関係を結ぶ相手を選択してください';
    }
    return null;
  }
  
  // 自己参照関係のチェック（通常は発生しないが、念のため）
  static String? validateSelfReference(String fromPersonId, String? toPersonId) {
    if (toPersonId != null && fromPersonId == toPersonId) {
      return '自分自身との関係は設定できません';
    }
    return null;
  }
  
  // 循環参照のチェック（親子関係の場合）
  static String? validateCircularReference(
    String fromPersonId,
    String? toPersonId,
    RelationType type,
    List<Relationship> relationships,
  ) {
    if (type != RelationType.parentChild || toPersonId == null) {
      return null;
    }
    
    // toPersonIdが既にfromPersonIdの親（または先祖）になっていないか確認
    final Set<String> ancestors = {};
    _findAncestors(fromPersonId, relationships, ancestors);
    
    if (ancestors.contains(toPersonId)) {
      return '循環する親子関係は設定できません';
    }
    
    return null;
  }
  
  // 先祖を再帰的に探索する補助メソッド
  static void _findAncestors(
    String personId,
    List<Relationship> relationships,
    Set<String> ancestors,
  ) {
    // 親を探す
    final parentRelations = relationships.where(
      (rel) => rel.type == RelationType.parentChild && rel.toPersonId == personId,
    );
    
    for (final relation in parentRelations) {
      final parentId = relation.fromPersonId;
      ancestors.add(parentId);
      _findAncestors(parentId, relationships, ancestors);
    }
  }
  
  // フォーム全体のバリデーション
  static String? validateRelationshipForm(
    RelationshipFormState form,
    List<Relationship> relationships,
  ) {
    // 関係先の人物チェック
    final toPersonIdError = validateToPersonId(form.toPersonId);
    if (toPersonIdError != null) {
      return toPersonIdError;
    }
    
    // 自己参照チェック
    final selfReferenceError = validateSelfReference(form.fromPersonId, form.toPersonId);
    if (selfReferenceError != null) {
      return selfReferenceError;
    }
    
    // 循環参照チェック
    final circularReferenceError = validateCircularReference(
      form.fromPersonId,
      form.toPersonId,
      form.type,
      relationships,
    );
    if (circularReferenceError != null) {
      return circularReferenceError;
    }
    
    return null;
  }
}
```

### 4.2 バリデーション実行

```dart
// バリデーション実行関数
bool validateRelationshipForm(WidgetRef ref) {
  // フォーム状態のバリデーション
  final formState = ref.read(relationshipFormProvider);
  final relationshipsAsync = ref.read(relationshipsStreamProvider);
  
  if (relationshipsAsync.asData == null) {
    // データがまだロードされていない場合
    ref.read(relationshipFormErrorProvider.notifier).state = '関係性データの読み込み中です';
    return false;
  }
  
  final relationships = relationshipsAsync.asData!.value;
  final error = RelationshipValidators.validateRelationshipForm(formState, relationships);
  
  if (error != null) {
    ref.read(relationshipFormErrorProvider.notifier).state = error;
    return false;
  }
  
  // エラーメッセージをクリア
  ref.read(relationshipFormErrorProvider.notifier).state = null;
  return true;
}
```

## 5. 画面遷移と操作フロー

### 5.1 関係性追加フロー

1. 人物詳細パネルまたは人物ノードのコンテキストメニューから「関係追加」ボタンをクリック
2. フォームを初期状態で初期化（基準となる人物IDを設定）
3. 関係性設定ダイアログを表示
4. ユーザーが関係タイプと関係先の人物を選択
5. 「設定」ボタンをクリック
6. バリデーション実行
7. バリデーション成功時：
   1. 保存中状態に設定
   2. RelationshipControllerを使って新規関係性を追加
   3. 成功時：ダイアログを閉じ、成功メッセージを表示
   4. 失敗時：エラーメッセージを表示
8. バリデーション失敗時：エラーメッセージを表示

### 5.2 関係性編集フロー

1. 既存の関係性を表す線や関係性リストから「編集」アクションを選択
2. 既存の関係性データでフォームを初期化
3. 関係性設定ダイアログを表示
4. ユーザーが関係タイプや関係先の人物を変更
5. 「設定」ボタンをクリック
6. バリデーション実行
7. バリデーション成功時：
   1. 保存中状態に設定
   2. RelationshipControllerを使って関係性情報を更新
   3. 成功時：ダイアログを閉じ、成功メッセージを表示
   4. 失敗時：エラーメッセージを表示
8. バリデーション失敗時：エラーメッセージを表示

### 5.3 関係性削除フロー

1. 関係性設定ダイアログで「関係削除」ボタンをクリック
2. 削除確認ダイアログを表示
3. ユーザーが「削除」ボタンをクリック
4. 保存中状態に設定
5. RelationshipControllerを使って関係性を削除
6. 成功時：編集ダイアログと確認ダイアログを閉じ、成功メッセージを表示
7. 失敗時：エラーメッセージを表示

## 6. エラーハンドリング

### 6.1 入力エラーの表示

```dart
// 入力エラーの表示
Widget _buildErrorMessage(String message) {
  return Container(
    margin: EdgeInsets.only(top: 16),
    padding: EdgeInsets.all(8),
    decoration: BoxDecoration(
      color: Colors.red.shade50,
      border: Border.all(color: Colors.red.shade200),
      borderRadius: BorderRadius.circular(4),
    ),
    child: Row(
      children: [
        Icon(Icons.error_outline, color: Colors.red),
        SizedBox(width: 8),
        Expanded(
          child: Text(
            message,
            style: TextStyle(color: Colors.red.shade800),
          ),
        ),
      ],
    ),
  );
}
```

### 6.2 エラー種別の分類と対応

```dart
// lib/features/relationship_editor/utils/error_handler.dart
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';

class RelationshipEditorErrorHandler {
  // エラー種別の判定
  static String getErrorMessage(dynamic error) {
    if (error is FirebaseException) {
      return _handleFirebaseError(error);
    } else if (error.toString().contains('既に同じ種類の関係')) {
      return '既に同じ種類の関係が設定されています';
    } else if (error.toString().contains('循環する親子関係')) {
      return '循環する親子関係は設定できません';
    } else {
      return '予期せぬエラーが発生しました: ${error.toString()}';
    }
  }
  
  // Firebaseエラーの処理
  static String _handleFirebaseError(FirebaseException error) {
    switch (error.code) {
      case 'permission-denied':
        return 'データへのアクセス権限がありません';
      case 'unavailable':
        return 'サーバーに接続できません。ネットワーク接続を確認してください';
      default:
        return 'Firebaseエラー: ${error.message}';
    }
  }
  
  // エラー表示スナックバー
  static void showErrorSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  
  // 成功表示スナックバー
  static void showSuccessSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
}
```

## 7. アクセシビリティ

### 7.1 アクセシビリティ対応

```dart
// lib/features/relationship_editor/presentation/accessibility/relationship_form_accessibility.dart
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:flutter/material.dart';

class RelationshipFormAccessibility {
  // 関係性の説明文を生成
  static String generateRelationshipDescription(
    Person? fromPerson,
    Person? toPerson,
    RelationType type,
  ) {
    if (fromPerson == null || toPerson == null) {
      return '関係情報を設定します';
    }
    
    if (type == RelationType.parentChild) {
      return '${fromPerson.name}は${toPerson.name}の親です';
    } else {
      return '${fromPerson.name}と${toPerson.name}は配偶者です';
    }
  }
  
  // フォーカス順序の管理
  static List<FocusNode> createFormFocusNodes() {
    return [
      FocusNode(), // 関係タイプ（親子関係）
      FocusNode(), // 関係タイプ（配偶者関係）
      FocusNode(), // 関係を結ぶ相手のドロップダウン
    ];
  }
  
  // 関係性設定ダイアログにアクセシビリティ機能を適用
  static Widget addAccessibility(Widget dialog, List<FocusNode> focusNodes) {
    return Semantics(
      label: '関係性設定ダイアログ',
      hint: 'この画面では人物間の関係を設定できます',
      child: dialog,
    );
  }
  
  // セマンティックラベルの生成
  static String generatePersonSelectorLabel(Person person) {
    String genderText = '';
    if (person.gender == Gender.male) {
      genderText = '男性';
    } else if (person.gender == Gender.female) {
      genderText = '女性';
    }
    
    return '${person.name}、${genderText}';
  }
}
```

### 7.2 キーボード操作の対応

```dart
// キーボード操作への対応
void _handleKeyboardShortcuts(RawKeyEvent event, BuildContext context) {
  if (event is RawKeyDownEvent) {
    if (event.isControlPressed && event.logicalKey == LogicalKeyboardKey.keyS) {
      // Ctrl+S で保存
      _saveRelationship(context, ref);
    } else if (event.logicalKey == LogicalKeyboardKey.escape) {
      // ESC でキャンセル
      Navigator.of(context).pop();
    }
  }
}
```

## 8. パフォーマンス最適化

### 8.1 関係先候補のキャッシュ

```dart
// 関係先候補の最適化
// 候補リストのキャッシング
final cachedAvailablePersonsProvider = Provider.family<AsyncValue<List<Person>>, String>((ref, fromPersonId) {
  // メモ化されたリスト
  final personsAsync = ref.watch(availablePersonsProvider(fromPersonId));
  
  // 30秒のキャッシュを適用
  ref.keepAlive(const Duration(seconds: 30));
  
  return personsAsync;
});
```

### 8.2 モーダルダイアログの最適化

```dart
// モーダルダイアログの最適化
void showOptimizedRelationshipDialog(
  BuildContext context,
  String fromPersonId,
  String? relationshipId,
) {
  final personTag = 'relationship_dialog';
  
  Navigator.of(context).push(
    PageRouteBuilder(
      opaque: false,
      barrierColor: Colors.black54,
      pageBuilder: (BuildContext context, _, __) {
        return Hero(
          tag: personTag,
          child: ResponsiveRelationshipDialog(
            child: RelationshipDialog(
              fromPersonId: fromPersonId,
              relationshipId: relationshipId,
            ),
          ),
        );
      },
    ),
  );
}
```

## 9. テスト計画

### 9.1 ウィジェットテスト

```dart
// test/features/relationship_editor/presentation/dialogs/relationship_dialog_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:chart_my_roots_app/features/relationship_editor/presentation/dialogs/relationship_dialog.dart';
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:mocktail/mocktail.dart';

// モッククラス
class MockRelationshipController extends Mock implements RelationshipController {}
class MockPerson extends Mock implements Person {}

void main() {
  late MockRelationshipController mockController;
  
  setUp(() {
    mockController = MockRelationshipController();
  });
  
  testWidgets('RelationshipDialog displays title based on isNew parameter', (WidgetTester tester) async {
    // モックデータの設定
    final mockFromPerson = MockPerson();
    when(() => mockFromPerson.id).thenReturn('person1');
    when(() => mockFromPerson.name).thenReturn('Test Person');
    
    final mockToPerson = MockPerson();
    when(() => mockToPerson.id).thenReturn('person2');
    when(() => mockToPerson.name).thenReturn('Related Person');
    
    final overrides = [
      relationshipControllerProvider.overrideWithValue(mockController),
      personByIdProvider('person1').overrideWith((ref) => AsyncValue.data(mockFromPerson)),
      availablePersonsProvider('person1').overrideWith((ref) => AsyncValue.data([mockToPerson])),
    ];
    
    // 新規追加ダイアログをビルド
    await tester.pumpWidget(
      ProviderScope(
        overrides: overrides,
        child: MaterialApp(
          home: Scaffold(
            body: Builder(
              builder: (context) => ElevatedButton(
                onPressed: () {
                  showDialog(
                    context: context,
                    builder: (_) => RelationshipDialog(
                      fromPersonId: 'person1',
                      relationshipId: null,
                    ),
                  );
                },
                child: Text('Open Dialog'),
              ),
            ),
          ),
        ),
      ),
    );
    
    // ダイアログを開く
    await tester.tap(find.text('Open Dialog'));
    await tester.pumpAndSettle();
    
    // 新規追加時のタイトルを確認
    expect(find.text('関係性追加'), findsOneWidget);
    
    // 他のテスト（省略）
  });
  
  // 他のテストケース（省略）
}
```

### 9.2 コントローラのテスト

```dart
// test/features/relationship_editor/application/relationship_controller_test.dart
import 'package:chart_my_roots_app/features/relationship_editor/application/relationship_controller.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:chart_my_roots_app/repositories/relationship_repository.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';

// モックリポジトリ
class MockRelationshipRepository extends Mock implements RelationshipRepository {}

void main() {
  late RelationshipController controller;
  late MockRelationshipRepository mockRepository;
  
  setUp(() {
    mockRepository = MockRelationshipRepository();
    controller = RelationshipController(mockRepository);
  });
  
  group('RelationshipController Tests', () {
    test('addRelationship throws exception when duplicate relationship exists', () async {
      // テスト用のデータ
      final relationship = Relationship(
        id: '',
        fromPersonId: 'person1',
        toPersonId: 'person2',
        type: RelationType.parentChild,
      );
      
      // 既存の関係を設定
      final existingRelationships = [
        Relationship(
          id: 'rel1',
          fromPersonId: 'person1',
          toPersonId: 'person2',
          type: RelationType.parentChild,
        ),
      ];
      
      // モックの動作を設定
      when(() => mockRepository.getRelationshipsOnce())
          .thenAnswer((_) async => existingRelationships);
      
      // 重複する関係性を追加しようとすると例外が発生することを確認
      expect(
        () => controller.addRelationship(relationship),
        throwsA(isA<Exception>()),
      );
    });
    
    test('addRelationship calls repository when no duplicate exists', () async {
      // テスト用のデータ
      final relationship = Relationship(
        id: '',
        fromPersonId: 'person1',
        toPersonId: 'person2',
        type: RelationType.parentChild,
      );
      
      // 空の関係リストを設定
      when(() => mockRepository.getRelationshipsOnce())
          .thenAnswer((_) async => []);
      
      // 追加成功時の動作を設定
      when(() => mockRepository.addRelationship(relationship))
          .thenAnswer((_) async => 'new-rel-id');
      
      // 関係性を追加
      final result = await controller.addRelationship(relationship);
      
      // リポジトリが呼ばれたことを確認
      verify(() => mockRepository.addRelationship(relationship)).called(1);
      
      // 結果を確認
      expect(result, equals('new-rel-id'));
    });
    
    // 他のテストケース（省略）
  });
}
```

### 9.3 バリデーションのテスト

```dart
// test/features/relationship_editor/utils/validators_test.dart
import 'package:chart_my_roots_app/features/relationship_editor/utils/validators.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('RelationshipValidators Tests', () {
    group('validateToPersonId', () {
      test('returns error message when toPersonId is null', () {
        expect(
          RelationshipValidators.validateToPersonId(null),
          '関係を結ぶ相手を選択してください',
        );
      });
      
      test('returns error message when toPersonId is empty', () {
        expect(
          RelationshipValidators.validateToPersonId(''),
          '関係を結ぶ相手を選択してください',
        );
      });
      
      test('returns null when toPersonId is valid', () {
        expect(RelationshipValidators.validateToPersonId('person2'), null);
      });
    });
    
    group('validateCircularReference', () {
      test('detects circular parent-child relationships', () {
        // person1 -> person2 -> person3 の親子関係
        final relationships = [
          Relationship(
            id: 'rel1',
            fromPersonId: 'person1',
            toPersonId: 'person2',
            type: RelationType.parentChild,
          ),
          Relationship(
            id: 'rel2',
            fromPersonId: 'person2',
            toPersonId: 'person3',
            type: RelationType.parentChild,
          ),
        ];
        
        // person3 -> person1 の関係を追加しようとすると循環になる
        expect(
          RelationshipValidators.validateCircularReference(
            'person3',
            'person1',
            RelationType.parentChild,
            relationships,
          ),
          '循環する親子関係は設定できません',
        );
      });
      
      test('allows non-circular parent-child relationships', () {
        // person1 -> person2, person1 -> person3 の親子関係
        final relationships = [
          Relationship(
            id: 'rel1',
            fromPersonId: 'person1',
            toPersonId: 'person2',
            type: RelationType.parentChild,
          ),
          Relationship(
            id: 'rel2',
            fromPersonId: 'person1',
            toPersonId: 'person3',
            type: RelationType.parentChild,
          ),
        ];
        
        // person2 -> person4 の関係は循環しない
        expect(
          RelationshipValidators.validateCircularReference(
            'person2',
            'person4',
            RelationType.parentChild,
            relationships,
          ),
          null,
        );
      });
    });
    
    // 他のテストケース（省略）
  });
}
```

## 10. まとめ

関係性設定画面は、家系図の構造を定義するための重要な機能です。本設計では以下のポイントを重視しています：

1. **直感的な関係設定**
   - 視覚的なプレビュー表示
   - 簡潔で明確な操作フロー
   - 関係性の意味が理解しやすいUI

2. **堅牢なバリデーション**
   - 関係先の選択確認
   - 重複する関係性の防止
   - 循環する親子関係の防止

3. **効率的な状態管理**
   - Riverpodによる明確な状態管理
   - フォーム状態とビジネスロジックの分離
   - 処理状態の適切な管理

4. **エラーハンドリング**
   - わかりやすいエラーメッセージ
   - 具体的な問題の指摘と解決方法の提示

5. **アクセシビリティ対応**
   - スクリーンリーダー対応
   - キーボード操作のサポート

これらの設計により、ユーザーが家系図内の人物間の関係を簡単かつ確実に設定できる機能を実現します。親子関係や配偶者関係といった基本的な関係性を設定することで、家系図の構造を正確に表現することができます。
