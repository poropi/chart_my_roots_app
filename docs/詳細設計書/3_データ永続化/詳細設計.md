# データ永続化機能 詳細設計書

## 1. 概要

データ永続化機能は、ユーザーが作成した家系図データを永続的に保存し、いつでもアクセスできるようにする機能です。主にFirebase Firestoreを使用したクラウド保存と、JSONファイルを介したエクスポート・インポート機能を提供します。Flutter/Dartでの実装を前提とした詳細設計を記載します。

## 2. クラス設計

### 2.1 ストレージ関連のモデルクラス

#### FamilyTreeData クラス

家系図データ全体を表すクラスです。エクスポート・インポート時に使用します。

```dart
// lib/models/family_tree_data.dart
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:flutter/foundation.dart';

part 'family_tree_data.freezed.dart';
part 'family_tree_data.g.dart';

@freezed
class FamilyTreeData with _$FamilyTreeData {
  const factory FamilyTreeData({
    required String id,
    required String name,
    @Default([]) List<Person> persons,
    @Default([]) List<Relationship> relationships,
    required DateTime lastModified,
  }) = _FamilyTreeData;

  factory FamilyTreeData.fromJson(Map<String, dynamic> json) =>
      _$FamilyTreeDataFromJson(json);
}
```

#### ExportData クラス

エクスポートデータ全体を表すクラスです。メタデータを含みます。

```dart
// lib/models/export_data.dart
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:flutter/foundation.dart';

part 'export_data.freezed.dart';
part 'export_data.g.dart';

@freezed
class ExportData with _$ExportData {
  const factory ExportData({
    required ExportMetadata metadata,
    required FamilyTreeData familyTree,
  }) = _ExportData;

  factory ExportData.fromJson(Map<String, dynamic> json) =>
      _$ExportDataFromJson(json);
}

@freezed
class ExportMetadata with _$ExportMetadata {
  const factory ExportMetadata({
    required String version,
    required DateTime exportDate,
    required String appName,
  }) = _ExportMetadata;

  factory ExportMetadata.fromJson(Map<String, dynamic> json) =>
      _$ExportMetadataFromJson(json);
}
```

### 2.2 リポジトリクラス

#### FamilyTreeStorageRepository インターフェース

データ永続化機能の抽象インターフェースです。

```dart
// lib/repositories/family_tree_storage_repository.dart
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/models/export_data.dart';

abstract class FamilyTreeStorageRepository {
  // Firestoreへの保存・読み込み
  Stream<List<FamilyTreeData>> getFamilyTrees();
  Stream<FamilyTreeData?> getFamilyTree(String treeId);
  Future<String> createFamilyTree(String name);
  Future<void> updateFamilyTree(FamilyTreeData familyTree);
  Future<void> deleteFamilyTree(String treeId);
  
  // エクスポート・インポート
  Future<ExportData> exportFamilyTree(String treeId);
  Future<String> importFamilyTree(ExportData exportData, ImportMode mode);
}

enum ImportMode {
  create,    // 新規作成
  merge,     // 既存データとマージ
  overwrite, // 既存データを上書き
}
```

#### FirestoreFamilyTreeRepository 実装クラス

Firebase Firestoreを使用した実装クラスです。

```dart
// lib/repositories/firestore_family_tree_repository.dart
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/models/export_data.dart';
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/models/relationship.dart';
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

class FirestoreFamilyTreeRepository implements FamilyTreeStorageRepository {
  final FirebaseFirestore _firestore;
  final String _userId;
  
  FirestoreFamilyTreeRepository({
    required FirebaseFirestore firestore,
    required String userId,
  }) : _firestore = firestore,
       _userId = userId;
  
  // 家系図一覧の取得
  @override
  Stream<List<FamilyTreeData>> getFamilyTrees() {
    return _firestore
        .collection('users/$_userId/familyTrees')
        .snapshots()
        .asyncMap((snapshot) async {
          final List<FamilyTreeData> result = [];
          
          for (final doc in snapshot.docs) {
            final treeId = doc.id;
            final treeData = doc.data();
            
            // 人物データの取得
            final personsSnapshot = await _firestore
                .collection('users/$_userId/familyTrees/$treeId/persons')
                .get();
            
            final List<Person> persons = personsSnapshot.docs
                .map((doc) => Person.fromFirestore(doc))
                .toList();
            
            // 関係性データの取得
            final relationshipsSnapshot = await _firestore
                .collection('users/$_userId/familyTrees/$treeId/relationships')
                .get();
            
            final List<Relationship> relationships = relationshipsSnapshot.docs
                .map((doc) => Relationship.fromFirestore(doc))
                .toList();
            
            result.add(FamilyTreeData(
              id: treeId,
              name: treeData['name'] as String,
              persons: persons,
              relationships: relationships,
              lastModified: (treeData['lastModified'] as Timestamp).toDate(),
            ));
          }
          
          return result;
        });
  }
  
  // 特定の家系図データの取得
  @override
  Stream<FamilyTreeData?> getFamilyTree(String treeId) {
    return _firestore
        .doc('users/$_userId/familyTrees/$treeId')
        .snapshots()
        .asyncMap((snapshot) async {
          if (!snapshot.exists) {
            return null;
          }
          
          final treeData = snapshot.data()!;
          
          // 人物データの取得
          final personsSnapshot = await _firestore
              .collection('users/$_userId/familyTrees/$treeId/persons')
              .get();
          
          final List<Person> persons = personsSnapshot.docs
              .map((doc) => Person.fromFirestore(doc))
              .toList();
          
          // 関係性データの取得
          final relationshipsSnapshot = await _firestore
              .collection('users/$_userId/familyTrees/$treeId/relationships')
              .get();
          
          final List<Relationship> relationships = relationshipsSnapshot.docs
              .map((doc) => Relationship.fromFirestore(doc))
              .toList();
          
          return FamilyTreeData(
            id: treeId,
            name: treeData['name'] as String,
            persons: persons,
            relationships: relationships,
            lastModified: (treeData['lastModified'] as Timestamp).toDate(),
          );
        });
  }
  
  // 新しい家系図の作成
  @override
  Future<String> createFamilyTree(String name) async {
    final docRef = await _firestore.collection('users/$_userId/familyTrees').add({
      'name': name,
      'lastModified': FieldValue.serverTimestamp(),
    });
    
    return docRef.id;
  }
  
  // 家系図データの更新
  @override
  Future<void> updateFamilyTree(FamilyTreeData familyTree) async {
    final batch = _firestore.batch();
    
    // 家系図メタデータを更新
    batch.set(
      _firestore.doc('users/$_userId/familyTrees/${familyTree.id}'),
      {
        'name': familyTree.name,
        'lastModified': FieldValue.serverTimestamp(),
      },
    );
    
    // 既存のデータを取得して差分を計算
    final existingPersonsSnapshot = await _firestore
        .collection('users/$_userId/familyTrees/${familyTree.id}/persons')
        .get();
    
    final existingRelationshipsSnapshot = await _firestore
        .collection('users/$_userId/familyTrees/${familyTree.id}/relationships')
        .get();
    
    // 既存IDのセット
    final existingPersonIds = existingPersonsSnapshot.docs
        .map((doc) => doc.id)
        .toSet();
    
    final existingRelationshipIds = existingRelationshipsSnapshot.docs
        .map((doc) => doc.id)
        .toSet();
    
    // 人物データの更新処理
    for (final person in familyTree.persons) {
      if (person.id.isEmpty) {
        // 新規作成の場合はIDを自動生成
        final newPersonRef = _firestore
            .collection('users/$_userId/familyTrees/${familyTree.id}/persons')
            .doc();
        batch.set(newPersonRef, person.toFirestore());
      } else {
        // 既存データの更新
        batch.set(
          _firestore.doc('users/$_userId/familyTrees/${familyTree.id}/persons/${person.id}'),
          person.toFirestore(),
        );
        existingPersonIds.remove(person.id);
      }
    }
    
    // 削除された人物を処理
    for (final idToDelete in existingPersonIds) {
      batch.delete(
        _firestore.doc('users/$_userId/familyTrees/${familyTree.id}/persons/$idToDelete'),
      );
    }
    
    // 関係性データの更新処理
    for (final relationship in familyTree.relationships) {
      if (relationship.id.isEmpty) {
        // 新規作成の場合はIDを自動生成
        final newRelationshipRef = _firestore
            .collection('users/$_userId/familyTrees/${familyTree.id}/relationships')
            .doc();
        batch.set(newRelationshipRef, relationship.toFirestore());
      } else {
        // 既存データの更新
        batch.set(
          _firestore.doc('users/$_userId/familyTrees/${familyTree.id}/relationships/${relationship.id}'),
          relationship.toFirestore(),
        );
        existingRelationshipIds.remove(relationship.id);
      }
    }
    
    // 削除された関係性を処理
    for (final idToDelete in existingRelationshipIds) {
      batch.delete(
        _firestore.doc('users/$_userId/familyTrees/${familyTree.id}/relationships/$idToDelete'),
      );
    }
    
    // バッチ処理を実行
    await batch.commit();
  }
  
  // 家系図の削除
  @override
  Future<void> deleteFamilyTree(String treeId) async {
    // 関連するすべてのサブコレクションを削除
    // 注意: Firestoreはサブコレクションを自動削除しないため、明示的に削除する必要がある
    
    // 人物データの削除
    final personsSnapshot = await _firestore
        .collection('users/$_userId/familyTrees/$treeId/persons')
        .get();
    
    final batch1 = _firestore.batch();
    for (final doc in personsSnapshot.docs) {
      batch1.delete(doc.reference);
    }
    await batch1.commit();
    
    // 関係性データの削除
    final relationshipsSnapshot = await _firestore
        .collection('users/$_userId/familyTrees/$treeId/relationships')
        .get();
    
    final batch2 = _firestore.batch();
    for (final doc in relationshipsSnapshot.docs) {
      batch2.delete(doc.reference);
    }
    await batch2.commit();
    
    // 家系図ドキュメント自体を削除
    await _firestore.doc('users/$_userId/familyTrees/$treeId').delete();
  }
  
  // 家系図データのエクスポート
  @override
  Future<ExportData> exportFamilyTree(String treeId) async {
    final familyTreeSnapshot = await _firestore
        .doc('users/$_userId/familyTrees/$treeId')
        .get();
    
    if (!familyTreeSnapshot.exists) {
      throw Exception('Family tree not found');
    }
    
    final treeData = familyTreeSnapshot.data()!;
    
    // 人物データの取得
    final personsSnapshot = await _firestore
        .collection('users/$_userId/familyTrees/$treeId/persons')
        .get();
    
    final List<Person> persons = personsSnapshot.docs
        .map((doc) => Person.fromFirestore(doc))
        .toList();
    
    // 関係性データの取得
    final relationshipsSnapshot = await _firestore
        .collection('users/$_userId/familyTrees/$treeId/relationships')
        .get();
    
    final List<Relationship> relationships = relationshipsSnapshot.docs
        .map((doc) => Relationship.fromFirestore(doc))
        .toList();
    
    final familyTree = FamilyTreeData(
      id: treeId,
      name: treeData['name'] as String,
      persons: persons,
      relationships: relationships,
      lastModified: (treeData['lastModified'] as Timestamp).toDate(),
    );
    
    // エクスポートメタデータの作成
    final metadata = ExportMetadata(
      version: '1.0',
      exportDate: DateTime.now(),
      appName: 'ChartMyRoots',
    );
    
    return ExportData(
      metadata: metadata,
      familyTree: familyTree,
    );
  }
  
  // 家系図データのインポート
  @override
  Future<String> importFamilyTree(ExportData exportData, ImportMode mode) async {
    switch (mode) {
      case ImportMode.create:
        return _createFromImport(exportData);
      case ImportMode.merge:
        return _mergeFromImport(exportData);
      case ImportMode.overwrite:
        return _overwriteFromImport(exportData);
    }
  }
  
  // 新規作成モードでのインポート
  Future<String> _createFromImport(ExportData exportData) async {
    // 新しい家系図ドキュメントを作成
    final docRef = await _firestore.collection('users/$_userId/familyTrees').add({
      'name': exportData.familyTree.name,
      'lastModified': FieldValue.serverTimestamp(),
    });
    
    final newTreeId = docRef.id;
    
    // 古いIDと新しいIDのマッピングを作成
    final Map<String, String> personIdMap = {};
    
    // 人物データをインポート
    for (final person in exportData.familyTree.persons) {
      final newPersonRef = _firestore
          .collection('users/$_userId/familyTrees/$newTreeId/persons')
          .doc();
      
      personIdMap[person.id] = newPersonRef.id;
      
      await newPersonRef.set(person.toFirestore());
    }
    
    // 関係性データをインポート（IDを更新）
    for (final relationship in exportData.familyTree.relationships) {
      final newFromId = personIdMap[relationship.fromPersonId];
      final newToId = personIdMap[relationship.toPersonId];
      
      if (newFromId != null && newToId != null) {
        final updatedRelationship = relationship.copyWith(
          fromPersonId: newFromId,
          toPersonId: newToId,
        );
        
        await _firestore
            .collection('users/$_userId/familyTrees/$newTreeId/relationships')
            .add(updatedRelationship.toFirestore());
      }
    }
    
    return newTreeId;
  }
  
  // マージモードでのインポート
  Future<String> _mergeFromImport(ExportData exportData) async {
    // 既存のツリーIDを使用するか、新しいものを作成
    String treeId = exportData.familyTree.id;
    bool isNewTree = false;
    
    // 対象の家系図が存在するか確認
    final treeSnapshot = await _firestore
        .doc('users/$_userId/familyTrees/$treeId')
        .get();
    
    if (!treeSnapshot.exists) {
      // 存在しない場合は新規作成
      final docRef = await _firestore.collection('users/$_userId/familyTrees').add({
        'name': exportData.familyTree.name,
        'lastModified': FieldValue.serverTimestamp(),
      });
      treeId = docRef.id;
      isNewTree = true;
    }
    
    // 既存の人物・関係性データを取得
    Map<String, Person> existingPersons = {};
    Map<String, Relationship> existingRelationships = {};
    
    if (!isNewTree) {
      final personsSnapshot = await _firestore
          .collection('users/$_userId/familyTrees/$treeId/persons')
          .get();
      
      existingPersons = {
        for (final doc in personsSnapshot.docs)
          doc.id: Person.fromFirestore(doc)
      };
      
      final relationshipsSnapshot = await _firestore
          .collection('users/$_userId/familyTrees/$treeId/relationships')
          .get();
      
      existingRelationships = {
        for (final doc in relationshipsSnapshot.docs)
          doc.id: Relationship.fromFirestore(doc)
      };
    }
    
    // バッチ処理で効率的に更新
    final batch = _firestore.batch();
    
    // 人物データのマージ
    for (final person in exportData.familyTree.persons) {
      if (person.id.isEmpty || !existingPersons.containsKey(person.id)) {
        // 新規作成
        final newPersonRef = _firestore
            .collection('users/$_userId/familyTrees/$treeId/persons')
            .doc();
        batch.set(newPersonRef, person.toFirestore());
      } else {
        // 既存データの更新
        batch.set(
          _firestore.doc('users/$_userId/familyTrees/$treeId/persons/${person.id}'),
          person.toFirestore(),
        );
      }
    }
    
    // 関係性データのマージ
    for (final relationship in exportData.familyTree.relationships) {
      if (relationship.id.isEmpty || !existingRelationships.containsKey(relationship.id)) {
        // 新規作成
        final newRelationshipRef = _firestore
            .collection('users/$_userId/familyTrees/$treeId/relationships')
            .doc();
        batch.set(newRelationshipRef, relationship.toFirestore());
      } else {
        // 既存データの更新
        batch.set(
          _firestore.doc('users/$_userId/familyTrees/$treeId/relationships/${relationship.id}'),
          relationship.toFirestore(),
        );
      }
    }
    
    // 家系図メタデータの更新
    batch.set(
      _firestore.doc('users/$_userId/familyTrees/$treeId'),
      {
        'name': exportData.familyTree.name,
        'lastModified': FieldValue.serverTimestamp(),
      },
    );
    
    // バッチ処理を実行
    await batch.commit();
    
    return treeId;
  }
  
  // 上書きモードでのインポート
  Future<String> _overwriteFromImport(ExportData exportData) async {
    // 既存のデータを一度削除してから新規作成
    final treeId = exportData.familyTree.id;
    
    // 対象の家系図が存在するか確認
    final treeSnapshot = await _firestore
        .doc('users/$_userId/familyTrees/$treeId')
        .get();
    
    if (treeSnapshot.exists) {
      // 既存データの削除
      await deleteFamilyTree(treeId);
    }
    
    // 新規作成と同じ処理
    final docRef = await _firestore.collection('users/$_userId/familyTrees').add({
      'name': exportData.familyTree.name,
      'lastModified': FieldValue.serverTimestamp(),
    });
    
    final newTreeId = docRef.id;
    
    // バッチ処理で効率的に作成
    final batch = _firestore.batch();
    
    // 人物データのインポート
    for (final person in exportData.familyTree.persons) {
      final newPersonRef = _firestore
          .collection('users/$_userId/familyTrees/$newTreeId/persons')
          .doc();
      batch.set(newPersonRef, person.toFirestore());
    }
    
    // 関係性データのインポート
    for (final relationship in exportData.familyTree.relationships) {
      final newRelationshipRef = _firestore
          .collection('users/$_userId/familyTrees/$newTreeId/relationships')
          .doc();
      batch.set(newRelationshipRef, relationship.toFirestore());
    }
    
    // バッチ処理を実行
    await batch.commit();
    
    return newTreeId;
  }
}
```

### 2.3 エクスポート・インポートサービス

#### ExportImportService クラス

JSONファイルを介したエクスポート・インポート処理を担当するサービスクラスです。

```dart
// lib/services/export_import_service.dart
import 'dart:convert';
import 'package:chart_my_roots_app/models/export_data.dart';
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:flutter/foundation.dart';
import 'package:universal_html/html.dart' as html;

class ExportImportService {
  final FamilyTreeStorageRepository _repository;
  
  ExportImportService(this._repository);
  
  // JSONファイルとしてエクスポート (Web向け)
  Future<void> exportToJson(String treeId) async {
    try {
      // 家系図データを取得
      final exportData = await _repository.exportFamilyTree(treeId);
      
      // JSONに変換
      final jsonString = jsonEncode(exportData.toJson());
      
      // ファイル名の生成
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = 'family_tree_${exportData.familyTree.name}_$timestamp.json';
      
      // Webの場合はブラウザのダウンロード機能を使用
      if (kIsWeb) {
        final bytes = utf8.encode(jsonString);
        final blob = html.Blob([bytes], 'application/json');
        final url = html.Url.createObjectUrlFromBlob(blob);
        
        final anchor = html.AnchorElement(href: url)
          ..setAttribute('download', fileName)
          ..click();
        
        // リソースリーク防止のためにURLを破棄
        html.Url.revokeObjectUrl(url);
      } else {
        // モバイル向けの実装（ここでは省略）
        // パッケージ：path_provider, file_savr などを使用
      }
    } catch (e) {
      rethrow;
    }
  }
  
  // JSON文字列からインポート
  Future<String> importFromJson(String jsonString, ImportMode mode) async {
    try {
      // JSONをパース
      final Map<String, dynamic> jsonData = jsonDecode(jsonString);
      
      // バリデーション
      _validateJsonStructure(jsonData);
      
      // ExportDataオブジェクトに変換
      final exportData = ExportData.fromJson(jsonData);
      
      // インポート処理を実行
      return await _repository.importFamilyTree(exportData, mode);
    } catch (e) {
      rethrow;
    }
  }
  
  // JSONデータの構造を検証
  void _validateJsonStructure(Map<String, dynamic> json) {
    if (!json.containsKey('metadata')) {
      throw FormatException('メタデータが見つかりません');
    }
    
    if (!json.containsKey('familyTree')) {
      throw FormatException('家系図データが見つかりません');
    }
    
    final familyTree = json['familyTree'] as Map<String, dynamic>;
    
    if (!familyTree.containsKey('persons')) {
      throw FormatException('人物データが見つかりません');
    }
    
    if (!familyTree.containsKey('relationships')) {
      throw FormatException('関係性データが見つかりません');
    }
  }
}
```

## 3. 状態管理（Riverpod）

### 3.1 データ永続化に関するプロバイダ

```dart
// lib/providers/storage_providers.dart
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:chart_my_roots_app/repositories/firestore_family_tree_repository.dart';
import 'package:chart_my_roots_app/services/export_import_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Firestore インスタンスプロバイダ
final firestoreProvider = Provider<FirebaseFirestore>((ref) {
  return FirebaseFirestore.instance;
});

// 現在のユーザーIDプロバイダ (認証プロバイダから取得するか、匿名IDを使用)
final userIdProvider = Provider<String>((ref) {
  // TODO: 実際の認証状態から取得する
  // 例: return ref.watch(authStateProvider).user?.uid ?? 'anonymous';
  return 'demo_user';
});

// ストレージリポジトリプロバイダ
final storageRepositoryProvider = Provider<FamilyTreeStorageRepository>((ref) {
  final firestore = ref.watch(firestoreProvider);
  final userId = ref.watch(userIdProvider);
  
  return FirestoreFamilyTreeRepository(
    firestore: firestore,
    userId: userId,
  );
});

// エクスポート・インポートサービスプロバイダ
final exportImportServiceProvider = Provider<ExportImportService>((ref) {
  final repository = ref.watch(storageRepositoryProvider);
  return ExportImportService(repository);
});

// 家系図一覧のStreamプロバイダ
final familyTreesStreamProvider = StreamProvider<List<FamilyTreeData>>((ref) {
  final repository = ref.watch(storageRepositoryProvider);
  return repository.getFamilyTrees();
});

// 現在選択中の家系図IDプロバイダ
final selectedFamilyTreeIdProvider = StateProvider<String?>((ref) => null);

// 選択中の家系図のStreamプロバイダ
final selectedFamilyTreeStreamProvider = StreamProvider<FamilyTreeData?>((ref) {
  final repository = ref.watch(storageRepositoryProvider);
  final treeId = ref.watch(selectedFamilyTreeIdProvider);
  
  if (treeId == null) {
    return Stream.value(null);
  }
  
  return repository.getFamilyTree(treeId);
});
```

### 3.2 エクスポート・インポート状態管理

```dart
// lib/providers/export_import_providers.dart
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// インポートモード選択プロバイダ
final importModeProvider = StateProvider<ImportMode>((ref) {
  return ImportMode.create;
});

// エクスポート・インポートの処理状態を管理するプロバイダ
final exportImportStateProvider = StateNotifierProvider<ExportImportNotifier, ExportImportState>((ref) {
  return ExportImportNotifier();
});

// エクスポート・インポートの状態
class ExportImportState {
  final bool isLoading;
  final String? errorMessage;
  final bool isSuccess;
  final String? successMessage;
  
  ExportImportState({
    this.isLoading = false,
    this.errorMessage,
    this.isSuccess = false,
    this.successMessage,
  });
  
  ExportImportState copyWith({
    bool? isLoading,
    String? errorMessage,
    bool? isSuccess,
    String? successMessage,
  }) {
    return ExportImportState(
      isLoading: isLoading ?? this.isLoading,
      errorMessage: errorMessage,
      isSuccess: isSuccess ?? this.isSuccess,
      successMessage: successMessage,
    );
  }
}

class ExportImportNotifier extends StateNotifier<ExportImportState> {
  ExportImportNotifier() : super(ExportImportState());
  
  // 処理開始
  void startLoading() {
    state = ExportImportState(isLoading: true);
  }
  
  // エラー設定
  void setError(String message) {
    state = ExportImportState(
      isLoading: false,
      errorMessage: message,
      isSuccess: false,
    );
  }
  
  // 成功設定
  void setSuccess(String message) {
    state = ExportImportState(
      isLoading: false,
      isSuccess: true,
      successMessage: message,
    );
  }
  
  // 状態リセット
  void reset() {
    state = ExportImportState();
  }
}
```

## 4. ネットワーク同期の制御

### 4.1 オフライン対応

```dart
// lib/services/connectivity_service.dart
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// ネットワーク接続状態のStreamプロバイダ
final connectivityStreamProvider = StreamProvider<ConnectivityResult>((ref) {
  return Connectivity().onConnectivityChanged;
});

// 現在のネットワーク接続状態プロバイダ
final isOnlineProvider = Provider<bool>((ref) {
  final connectivity = ref.watch(connectivityStreamProvider);
  
  return connectivity.when(
    data: (result) => result != ConnectivityResult.none,
    loading: () => true, // デフォルトはオンライン扱い
    error: (_, __) => false,
  );
});

// オフライン対応のFirestore設定
void configureFirestoreOfflineSupport(FirebaseFirestore firestore) {
  firestore.settings = Settings(
    persistenceEnabled: true,
    cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
  );
}
```

### 4.2 同期状態管理

```dart
// lib/providers/sync_state_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 同期状態の列挙型
enum SyncState {
  synced,      // 同期済み
  syncing,     // 同期中
  pendingSync, // 同期待ち
  error,       // エラー
}

// 同期状態プロバイダ
final syncStateProvider = StateProvider<SyncState>((ref) {
  final isOnline = ref.watch(isOnlineProvider);
  
  if (!isOnline) {
    return SyncState.pendingSync;
  }
  
  return SyncState.synced;
});

// 同期エラーメッセージプロバイダ
final syncErrorMessageProvider = StateProvider<String?>((ref) => null);

// 同期コントローラー
class SyncController {
  final Ref _ref;
  
  SyncController(this._ref);
  
  void setSyncing() {
    _ref.read(syncStateProvider.notifier).state = SyncState.syncing;
  }
  
  void setSynced() {
    _ref.read(syncStateProvider.notifier).state = SyncState.synced;
    _ref.read(syncErrorMessageProvider.notifier).state = null;
  }
  
  void setPendingSync() {
    _ref.read(syncStateProvider.notifier).state = SyncState.pendingSync;
  }
  
  void setError(String message) {
    _ref.read(syncStateProvider.notifier).state = SyncState.error;
    _ref.read(syncErrorMessageProvider.notifier).state = message;
  }
}

// 同期コントローラープロバイダ
final syncControllerProvider = Provider<SyncController>((ref) {
  return SyncController(ref);
});
```

## 5. セキュリティ

### 5.1 Firestore セキュリティルール

```javascript
// firestore.rules
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{userId} {
      // ユーザー自身のデータのみアクセス可能
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      match /familyTrees/{treeId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
        
        match /persons/{personId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
        
        match /relationships/{relationshipId} {
          allow read, write: if request.auth != null && request.auth.uid == userId;
        }
      }
    }
  }
}
```

### 5.2 匿名認証のサポート

```dart
// lib/services/auth_service.dart
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Firebase Auth インスタンスプロバイダ
final firebaseAuthProvider = Provider<FirebaseAuth>((ref) {
  return FirebaseAuth.instance;
});

// 認証状態のStreamプロバイダ
final authStateProvider = StreamProvider<User?>((ref) {
  return ref.watch(firebaseAuthProvider).authStateChanges();
});

// 匿名認証サービス
class AnonymousAuthService {
  final FirebaseAuth _auth;
  
  AnonymousAuthService(this._auth);
  
  // 匿名サインイン
  Future<UserCredential> signInAnonymously() async {
    return await _auth.signInAnonymously();
  }
  
  // サインアウト
  Future<void> signOut() async {
    await _auth.signOut();
  }
}

// 匿名認証サービスプロバイダ
final anonymousAuthServiceProvider = Provider<AnonymousAuthService>((ref) {
  final auth = ref.watch(firebaseAuthProvider);
  return AnonymousAuthService(auth);
});
```

## 6. UI実装

### 6.1 エクスポート・インポートダイアログ

```dart
// lib/features/data_persistence/presentation/dialogs/export_import_dialog.dart
import 'package:chart_my_roots_app/providers/export_import_providers.dart';
import 'package:chart_my_roots_app/providers/storage_providers.dart';
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class ExportImportDialog extends ConsumerWidget {
  final bool isExport;
  
  const ExportImportDialog({
    Key? key,
    required this.isExport,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 選択中の家系図ID
    final selectedTreeId = ref.watch(selectedFamilyTreeIdProvider);
    
    // エクスポート・インポート状態
    final exportImportState = ref.watch(exportImportStateProvider);
    
    // サービス
    final exportImportService = ref.watch(exportImportServiceProvider);
    
    return AlertDialog(
      title: Text(isExport ? 'データのエクスポート' : 'データのインポート'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (isExport) ...[
            Text('現在の家系図データをJSONファイルとしてエクスポートします。'),
            SizedBox(height: 16),
            Text('ファイルはダウンロードフォルダに保存されます。'),
          ] else ...[
            Text('JSONファイルから家系図データをインポートします。'),
            SizedBox(height: 16),
            _buildImportModeSelector(ref),
            SizedBox(height: 16),
            _buildFileUploadSection(context, ref),
          ],
          
          if (exportImportState.isLoading)
            Center(child: CircularProgressIndicator()),
          
          if (exportImportState.errorMessage != null)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Text(
                exportImportState.errorMessage!,
                style: TextStyle(color: Colors.red),
              ),
            ),
          
          if (exportImportState.isSuccess)
            Padding(
              padding: const EdgeInsets.only(top: 8.0),
              child: Text(
                exportImportState.successMessage!,
                style: TextStyle(color: Colors.green),
              ),
            ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () {
            Navigator.of(context).pop();
          },
          child: Text('キャンセル'),
        ),
        if (isExport)
          ElevatedButton(
            onPressed: exportImportState.isLoading
                ? null
                : () async {
                    if (selectedTreeId == null) {
                      ref.read(exportImportStateProvider.notifier).setError(
                        'エクスポートする家系図が選択されていません。',
                      );
                      return;
                    }
                    
                    try {
                      ref.read(exportImportStateProvider.notifier).startLoading();
                      await exportImportService.exportToJson(selectedTreeId);
                      ref.read(exportImportStateProvider.notifier).setSuccess(
                        'エクスポートが完了しました。',
                      );
                    } catch (e) {
                      ref.read(exportImportStateProvider.notifier).setError(
                        'エクスポート中にエラーが発生しました: $e',
                      );
                    }
                  },
            child: Text('エクスポート'),
          ),
      ],
    );
  }
  
  Widget _buildImportModeSelector(WidgetRef ref) {
    final importMode = ref.watch(importModeProvider);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('インポートモード:'),
        RadioListTile<ImportMode>(
          title: Text('新規作成'),
          subtitle: Text('新しい家系図として追加します'),
          value: ImportMode.create,
          groupValue: importMode,
          onChanged: (value) {
            ref.read(importModeProvider.notifier).state = value!;
          },
        ),
        RadioListTile<ImportMode>(
          title: Text('マージ'),
          subtitle: Text('既存データと統合します'),
          value: ImportMode.merge,
          groupValue: importMode,
          onChanged: (value) {
            ref.read(importModeProvider.notifier).state = value!;
          },
        ),
        RadioListTile<ImportMode>(
          title: Text('上書き'),
          subtitle: Text('既存データを完全に置き換えます'),
          value: ImportMode.overwrite,
          groupValue: importMode,
          onChanged: (value) {
            ref.read(importModeProvider.notifier).state = value!;
          },
        ),
      ],
    );
  }
  
  Widget _buildFileUploadSection(BuildContext context, WidgetRef ref) {
    // Webアップロード用のUI
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('インポートするJSONファイルを選択:'),
        SizedBox(height: 8),
        ElevatedButton.icon(
          icon: Icon(Icons.upload_file),
          label: Text('ファイルを選択'),
          onPressed: () {
            // Webファイル選択ダイアログ処理（略）
            // 実際のコードではFilePicker等のパッケージを使用
          },
        ),
      ],
    );
  }
}
```

### 6.2 同期状態表示ウィジェット

```dart
// lib/features/data_persistence/presentation/widgets/sync_status_indicator.dart
import 'package:chart_my_roots_app/providers/sync_state_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class SyncStatusIndicator extends ConsumerWidget {
  const SyncStatusIndicator({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final syncState = ref.watch(syncStateProvider);
    final errorMessage = ref.watch(syncErrorMessageProvider);
    
    // 同期状態に応じたアイコンと色
    IconData icon;
    Color color;
    String tooltip;
    
    switch (syncState) {
      case SyncState.synced:
        icon = Icons.cloud_done;
        color = Colors.green;
        tooltip = '同期済み';
        break;
      case SyncState.syncing:
        icon = Icons.sync;
        color = Colors.blue;
        tooltip = '同期中...';
        break;
      case SyncState.pendingSync:
        icon = Icons.cloud_off;
        color = Colors.orange;
        tooltip = 'オフライン: 同期待ち';
        break;
      case SyncState.error:
        icon = Icons.error_outline;
        color = Colors.red;
        tooltip = 'エラー: ${errorMessage ?? "同期エラー"}';
        break;
    }
    
    return Tooltip(
      message: tooltip,
      child: InkWell(
        onTap: () {
          // エラー時は詳細を表示
          if (syncState == SyncState.error && errorMessage != null) {
            _showErrorDialog(context, errorMessage);
          }
        },
        child: Container(
          padding: EdgeInsets.all(4),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                icon,
                color: color,
                size: 18,
              ),
              if (syncState == SyncState.syncing)
                Container(
                  width: 12,
                  height: 12,
                  margin: EdgeInsets.only(left: 4),
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    color: color,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
  
  void _showErrorDialog(BuildContext context, String errorMessage) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('同期エラー'),
        content: Text(errorMessage),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
            },
            child: Text('閉じる'),
          ),
        ],
      ),
    );
  }
}
```

## 7. エラーハンドリング

### 7.1 データ操作例外

```dart
// lib/exceptions/storage_exceptions.dart
// データ永続化に関連する例外クラス

// 基底例外クラス
class StorageException implements Exception {
  final String message;
  final dynamic originalError;
  
  StorageException(this.message, [this.originalError]);
  
  @override
  String toString() => 'StorageException: $message${originalError != null ? ' ($originalError)' : ''}';
}

// 具体的な例外クラス
class FamilyTreeNotFoundException extends StorageException {
  FamilyTreeNotFoundException([String? treeId])
      : super('家系図が見つかりません${treeId != null ? ' (ID: $treeId)' : ''}');
}

class NetworkErrorException extends StorageException {
  NetworkErrorException([dynamic originalError])
      : super('ネットワークエラーが発生しました', originalError);
}

class DataValidationException extends StorageException {
  DataValidationException(String message) : super(message);
}

class ImportFormatException extends StorageException {
  ImportFormatException(String message) : super('インポートデータのフォーマットが不正です: $message');
}

class AuthorizationException extends StorageException {
  AuthorizationException() : super('操作を実行する権限がありません');
}
```

### 7.2 例外ハンドラー

```dart
// lib/utils/error_handler.dart
import 'package:chart_my_roots_app/exceptions/storage_exceptions.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

class ErrorHandler {
  // Firestore例外をアプリ固有の例外に変換
  static Exception handleFirestoreError(FirebaseException error) {
    switch (error.code) {
      case 'permission-denied':
        return AuthorizationException();
      case 'unavailable':
        return NetworkErrorException(error);
      case 'not-found':
        return FamilyTreeNotFoundException();
      default:
        return StorageException('Firestore操作エラー: ${error.message}', error);
    }
  }
  
  // 認証例外をアプリ固有の例外に変換
  static Exception handleAuthError(FirebaseAuthException error) {
    // 認証関連のエラーハンドリング
    return StorageException('認証エラー: ${error.message}', error);
  }
  
  // ユーザーへのエラー表示
  static void showErrorSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
  
  // 成功メッセージの表示
  static void showSuccessSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
        behavior: SnackBarBehavior.floating,
      ),
    );
  }
}
```

## 8. テスト計画

### 8.1 リポジトリテスト

```dart
// test/repositories/firestore_family_tree_repository_test.dart
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/models/person.dart';
import 'package:chart_my_roots_app/repositories/firestore_family_tree_repository.dart';
import 'package:fake_cloud_firestore/fake_cloud_firestore.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  late FakeFirebaseFirestore fakeFirestore;
  late FirestoreFamilyTreeRepository repository;
  
  setUp(() {
    fakeFirestore = FakeFirebaseFirestore();
    repository = FirestoreFamilyTreeRepository(
      firestore: fakeFirestore,
      userId: 'test_user',
    );
  });
  
  group('FirestoreFamilyTreeRepository Tests', () {
    test('createFamilyTree creates a new family tree document', () async {
      final treeId = await repository.createFamilyTree('Test Family Tree');
      
      expect(treeId, isNotEmpty);
      
      final doc = await fakeFirestore
          .collection('users/test_user/familyTrees')
          .doc(treeId)
          .get();
      
      expect(doc.exists, isTrue);
      expect(doc.data()?['name'], equals('Test Family Tree'));
    });
    
    test('getFamilyTrees returns all family trees', () async {
      // テストデータをセットアップ
      await fakeFirestore.collection('users/test_user/familyTrees').add({
        'name': 'Family Tree 1',
        'lastModified': DateTime.now(),
      });
      
      await fakeFirestore.collection('users/test_user/familyTrees').add({
        'name': 'Family Tree 2',
        'lastModified': DateTime.now(),
      });
      
      // Stream from getFamilyTrees をテスト
      final stream = repository.getFamilyTrees();
      final result = await stream.first;
      
      expect(result.length, equals(2));
      expect(
        result.map((tree) => tree.name).toList()..sort(),
        equals(['Family Tree 1', 'Family Tree 2']..sort()),
      );
    });
    
    // 他のテストケース（省略）
  });
}
```

### 8.2 サービステスト

```dart
// test/services/export_import_service_test.dart
import 'dart:convert';
import 'package:chart_my_roots_app/models/export_data.dart';
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:chart_my_roots_app/services/export_import_service.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

class MockFamilyTreeStorageRepository extends Mock
    implements FamilyTreeStorageRepository {}

void main() {
  late MockFamilyTreeStorageRepository mockRepository;
  late ExportImportService service;
  
  setUp(() {
    mockRepository = MockFamilyTreeStorageRepository();
    service = ExportImportService(mockRepository);
  });
  
  group('ExportImportService Tests', () {
    test('importFromJson validates JSON structure', () async {
      // 不正なJSON形式
      final invalidJson = jsonEncode({
        'metadata': {
          'version': '1.0',
          'exportDate': DateTime.now().toIso8601String(),
          'appName': 'ChartMyRoots',
        },
        // familyTreeが欠落
      });
      
      expect(
        () => service.importFromJson(invalidJson, ImportMode.create),
        throwsA(isA<FormatException>()),
      );
    });
    
    test('importFromJson calls repository with correct data', () async {
      // 有効なJSON形式
      final familyTree = FamilyTreeData(
        id: 'tree1',
        name: 'Test Tree',
        persons: [],
        relationships: [],
        lastModified: DateTime.now(),
      );
      
      final exportData = ExportData(
        metadata: ExportMetadata(
          version: '1.0',
          exportDate: DateTime.now(),
          appName: 'ChartMyRoots',
        ),
        familyTree: familyTree,
      );
      
      final validJson = jsonEncode(exportData.toJson());
      
      when(mockRepository.importFamilyTree(any, any))
          .thenAnswer((_) async => 'new_tree_id');
      
      final result = await service.importFromJson(validJson, ImportMode.create);
      
      expect(result, equals('new_tree_id'));
      verify(mockRepository.importFamilyTree(any, ImportMode.create)).called(1);
    });
    
    // 他のテストケース（省略）
  });
}
```

### 8.3 プロバイダテスト

```dart
// test/providers/storage_providers_test.dart
import 'package:chart_my_roots_app/models/family_tree_data.dart';
import 'package:chart_my_roots_app/providers/storage_providers.dart';
import 'package:chart_my_roots_app/repositories/family_tree_storage_repository.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

class MockFamilyTreeStorageRepository extends Mock
    implements FamilyTreeStorageRepository {}

void main() {
  late ProviderContainer container;
  late MockFamilyTreeStorageRepository mockRepository;
  
  setUp(() {
    mockRepository = MockFamilyTreeStorageRepository();
    
    container = ProviderContainer(
      overrides: [
        storageRepositoryProvider.overrideWithValue(mockRepository),
      ],
    );
  });
  
  group('Storage Providers Tests', () {
    test('familyTreesStreamProvider provides repository stream', () async {
      // モックデータをセットアップ
      final mockTrees = [
        FamilyTreeData(
          id: 'tree1',
          name: 'Test Tree 1',
          lastModified: DateTime.now(),
        ),
      ];
      
      when(mockRepository.getFamilyTrees())
          .thenAnswer((_) => Stream.value(mockTrees));
      
      // プロバイダの値を取得
      final streamValue = await container.read(familyTreesStreamProvider.future);
      
      expect(streamValue, equals(mockTrees));
      verify(mockRepository.getFamilyTrees()).called(1);
    });
    
    test('selectedFamilyTreeStreamProvider returns null when no tree selected', () async {
      // 選択されていない状態をセットアップ
      container.read(selectedFamilyTreeIdProvider.notifier).state = null;
      
      // プロバイダの値を取得
      final streamValue = await container.read(selectedFamilyTreeStreamProvider.future);
      
      expect(streamValue, isNull);
      verifyNever(mockRepository.getFamilyTree(any));
    });
    
    // 他のテストケース（省略）
  });
}
```

## 9. まとめ

データ永続化機能は、家系図アプリのデータを安全に保存し、デバイス間で同期するための重要な機能です。以下のポイントを重視して設計しています：

1. **Firebase Firestoreによるクラウド保存**
   - リアルタイム同期機能
   - オフライン対応
   - 複数デバイス間の同期

2. **JSONエクスポート・インポート**
   - 完全なバックアップとリストア機能
   - 柔軟なインポートモード（新規/マージ/上書き）
   - 厳格なデータ検証

3. **ロバストなエラーハンドリング**
   - 意味のある例外クラス階層
   - ユーザーフレンドリーなエラー表示
   - ネットワークエラーからの回復

4. **セキュリティ**
   - 適切なFirestoreセキュリティルール
   - 匿名認証のサポート
   - データ検証

これらの機能により、ユーザーは家系図データを安全に保存し、必要に応じてバックアップやデバイス間での移行を行うことができます。
